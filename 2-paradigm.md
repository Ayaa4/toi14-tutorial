# Table of Contents

**2. Problem Solving Paradigms**
  - 2.1 Brute Force
    - 2.1.1 Iterative Complete Search
    - 2.1.2 Recursive Complete Search
    - 2.1.3 Simulation
  - 2.2 Divide and Conquer
    - 2.2.1 Binary Search
    - 2.2.2 การแปลง Optimization Problem เป็น Decision Problem
  - 2.3 Greedy
  - 2.4 Dynamic Programming
    - 2.4.1 Example: Fibonacci Numbers
    - 2.4.2 Top-down DP (Memoization)
    - 2.4.3 Bottom-up DP
    - 2.4.4 ใช้ Top-down หรือ Bottom-up ดี?
    - 2.4.5 Example: Coin Change Problem
    - 2.4.6 Multi-dimensional DP Example: Maximum Monotonic Path

# 2. Problem Solving Paradigms

## 2.1 Brute Force

Brute Force เป็นวิธีการแก้ปัญหาที่ง่ายที่สุด เพราะไม่จำเป็นต้องคิดวิธีที่ดีอะไรมาก เพียงแค่ทดลองทุกคำตอบ/ทุกกรณีที่เป็นไปได้ แล้วตอบคำตอบที่ดีที่สุด (หรือตอบจำนวนวิธีที่เป็นไปได้ หากโจทย์ถามหาจำนวนวิธีในการทำอะไรบางอย่าง) จะหนักที่การ implement ซะมากกว่า

ถึงโจทย์ส่วนใหญ่จะให้คะแนนวิธีนี้น้อย เราควรศึกษาและฝึก implement Brute Force ให้ดี ๆ เพราะหากหาวิธีที่ดีไม่ได้ การทำ Brute Force ก็อาจจะช่วยให้ได้คะแนนได้บางส่วน

### 2.1.1 Iterative Complete Search

โจทย์บางข้อสามารถ Brute Force ได้โดยการทดลองลูปบนคำตอบทั้งหมดที่เป็นไปได้ โดยอาจจะลูปหลายชั้น เช่น

> กำหนดลำดับตัวเลขมาให้ `n` ตัว ให้เลือกตัวเลขสองตัวที่มีค่าต่างกันน้อยที่สุดที่เป็นไปได้

วิธีหนึ่งที่ทำได้ คือลูปสองชั้นเพื่อทดลองเลือกตัวเลขสองตัวทุกแบบที่เป็นไปได้ หาวิธีการเลือกที่ได้ค่าแตกต่างกันน้อยที่สุดแล้วตอบ

> กำหนดจำนวนเต็ม `A` และ `B` ให้ จงหาจำนวนเต็มบวก `x` และ `y` ทุกคู่ที่ตรงตามเงื่อนไข `x+y = A` และ `x*y = B`

ใช้การทดลองลูปสองชั้นเพื่อทดลองค่า `x`, `y` ทั้งหมดที่เป็นไปได้ (ไม่เกิน `A` หรือ `B`) แล้วตรวจสอบเงื่อนไขทั้งสองเงื่อนไข ถ้าตรงเงื่อนไขก็ตอบคู่นั้น วิธีนี้จะใช้เวลา `O(min(A, B)^2)`

สังเกตว่าความจริงแล้วเราไม่จำเป็นต้องลูปค่า `y` ก็ได้ เพราะหากเลือกค่า `x` แล้ว เราสามารถสรุปได้ทันทีว่า `y = A-x` ตามสมการแรก สิ่งที่ต้องทำมีเพียงแค่การตรวจสอบเงื่อนไข `x*y = B` ว่าเป็นจริงหรือไม่ วิธีนี้จะใช้เวลา `O(min(A, B))`

### 2.1.2 Recursive Complete Search

โจทย์บางข้อจำเป็นต้องทดลองวิธีเป็นจำนวนมาก และไม่สามารถใช้ลูปหลายชั้นในการแก้ได้ ดังนั้นจึงต้องเขียน recursive function เพื่อทดลองเลือกทุกวิธีที่เป็นไปได้แทน

**Perket - COCI 2008/2009 Contest #2**

> ต้องการทำอาหาร มีส่วนผสมให้ทั้งหมด `n` ชิ้น (`n <= 10`) โดยส่วนผสมแต่ละชิ้นจะมีค่าความเปรี้ยวและค่าความขม ให้เลือกส่วนผสมมาทำอาหาร (เลือกกี่ชิ้นก็ได้ แต่ต้องอย่างน้อย 1 ชิ้น) เมื่อทำอาหาร จะได้อาหารที่มีค่าความเปรี้ยวเท่ากับผลคูณของค่าความเปรี้ยวของส่วนผสมที่เลือกมา ส่วนค่าความขมจะเท่ากับผลบวกของค่าความขมของส่วนผสมที่เลือกมา ให้หาวิธีเลือกโดยให้ความต่างระหว่างค่าความขมกับค่าความเปรี้ยวน้อยที่สุดเท่าที่เป็นไปได้
>

สังเกตว่าเราต้องการทดลองเลือกทุกสับเซตที่เป็นไปได้ (ยกเว้นเซตว่าง) แล้วหาสับเซตที่มีค่าความต่างน้อยที่สุด วิธีการหนึ่งที่เป็นไปได้คือการเลือกตัดสินใจว่า ชิ้นที่ 1 จะเอาหรือไม่ ชิ้นที่ 2 จะเอาหรือไม่, ..., ชิ้นที่ `n` จะเอาหรือไม่

ในการทดลอง เราสร้าง array ของ `bool` ชื่อ `picked` ขึ้นมา โดยนิยามให้ `picked[i]` เป็น `true` ถ้าเลือกใช้ส่วนผสมชิ้นที่ `i` และเป็น `false` ถ้าไม่เลือกใช้

ต่อมา กำหนดฟังก์ชัน recursive ชื่อ `pick(i)` ซึ่งจะทำหน้าที่กำหนดค่าให้ `picked[i]` เป็น `true`, เรียก `pick(i+1)` เพื่อทำการเลือกส่วนผสมชิ้นถัด ๆ ไปทุกแบบที่เป็นไปได้ เมื่อ return กลับมาแล้วจึงกำหนดค่าให้ `picked[i]` เป็น `false` แล้วเรียก `pick(i+1)` เพื่อทดลองทุกความเป็นไปได้เช่นเดียวกัน

ในกรณีที่เรียก `pick(n+1)` จะถือว่าทดลองเลือกของมาแล้ววิธีหนึ่งตามที่ระบุใน array `picked`, ฟังก์ชันจะทำการคำนวณค่าความต่าง พร้อมเช็คเงื่อนไขเพื่อให้มั่นใจว่าไม่ได้เลือกเซตว่างมา หากค่าความต่างน้อยกว่าค่าความต่างน้อยสุดที่เคยเก็บไว้ ก็ให้จดคำตอบใหม่

ดูโค้ดตัวอย่างด้านล่าง

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20;
const int INF = 1e9;

int n;
int sour[N], bitter[N];
bool picked[N];
int ans = INF;

void pick(int i)
{
    if (i <= n) {
        picked[i] = true;
        pick(i+1);
        picked[i] = false;
        pick(i+1);
    } else { // i == n+1
        int total_sour = 1, total_bitter = 0, count_used = 0;
        for (int j = 1; j <= n; ++j) {
            if (picked[j]) {
                ++count_used;
                total_sour *= sour[j];
                total_bitter += bitter[j];
            }
        }
        if (count_used != 0)
            ans = min(ans, abs(total_sour - total_bitter));
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d%d", &sour[i], &bitter[i]);
    pick(1);
    printf("%d\n", ans);
    
    return 0;
}
```

**N-Queen Problem**

> มีกระดานหมากรุกขนาด `n*n` ให้วาง Queen ทั้งหมด `n` ตัวโดยที่ Queen แต่ละตัวต้องไม่ attack Queen ตัวอื่น (จะ attack ก็ต่อเมื่ออยู่ในแถว/คอลัมน์/แนวทแยงเดียวกันเท่านั้น)

แต่ละแถว จะต้องเลือกตำแหน่งให้ queen อยู่ ณ คอลัมน์ใดคอลัมน์หนึ่ง โดยเมื่อเลือกเสร็จแล้ว ต้องตรวจสอบว่าแต่ละคอลัมน์ถูกเลือกเพียงครั้งเดียวเท่านั้น นอกจากนี้ queen แต่ละตัวต้องไม่อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่น ๆ ด้วย หากไม่ขัดเงื่อนไขก็สามารถตอบวิธีการวางดังกล่าวได้

สังเกตว่า เราไม่จำเป็นต้องรอจนจบแล้วค่อยเช็คเงื่อนไขก็ได้ แต่สามารถเช็คระหว่างเลือกได้เลย หากพบว่าเลือกแล้วขัดเงื่อนไขใดเงื่อนไขหนึ่ง ก็ให้ข้ามตัวเลือกนั้น แล้วทดลองเลือกตำแหน่งถัดไปได้เลย วิธีดังกล่าวเรียกว่า Recursive Backtracking

### 2.1.3 Simulation

โจทย์บางข้อกำหนดสถานการณ์มาให้ แล้วคุณต้องตอบคำถามตามที่โจทย์กำหนด วิธีที่ง่ายที่สุดวิธีหนึ่งคือการ implement โค้ดเพื่อจำลองสถานการณ์แล้วตอบคำถาม

> กำหนดลำดับจำนวนเต็ม `1` ถึง `n` มาให้ ให้ทำการ sort array ดังกล่าวด้วย bubble sort - มีคำถามมาให้ `q` คำถาม แต่ละคำถามถามว่า ใน bubble sort pass ที่ `k` ตัวเลข `x` อยู่ที่ตำแหน่งใด

เราอาจจะสร้าง array 2 มิติขึ้นมาเพื่อเก็บสภาพของ array หลังการ bubble sort แต่ละรอบ แล้วตอบคำถามแต่ละคำถาม

## 2.2 Divide and Conquer

แนวคิดหลัก ๆ ของ Divide and Conquer คือ แบ่งปัญหาออกเป็นหลายส่วนที่เท่า ๆ กัน ใช้อัลกอริทึมเดิมแก้ปัญหาย่อย ๆ ซ้ำแบบ recursive แล้วหาวิธีรวมคำตอบเข้าด้วยกัน เป็นคำตอบของปัญหาใหญ่ (โดยส่วนใหญ่ จะแบ่งออกเป็น 2 ส่วนเท่า ๆ กัน)

ยกตัวอย่างอัลกอริทึม Divide and Conquer เช่น Merge Sort ที่ใช้การ sort array ครึ่งแรกกับครึ่งหลังแยกกัน แล้วค่อยนำ array ทั้งสองมารวมกัน เนื่องจากว่ามีการแบ่งครึ่งลงไปทั้งหมด `O(log n)` ชั้น แต่ละชั้นจะต้องจัดการกับสมาชิกของ array เพื่อทำการรวม array - รวมทั้งหมด `O(n)` ตัว ทำให้เวลาการทำงานของ merge sort เป็น `O(n log n)`

ในการแข่งขัน TOI ปกติจะไม่ค่อยเจอโจทย์ Divide and Conquer ท่าแปลก ๆ มาก ยกเว้นการ Binary Search บนปัญหา Optimization Problem ที่ถูกแปลงเป็น Decision Problem ซึ่งพบได้บ่อยมาก ควรศึกษาไว้

### 2.2.1 Binary Search

> กำหนดลำดับจำนวนให้ทั้งหมด `n` ตัว มีคำถามให้ `q` คำถาม แต่ละคำถาม ให้หาว่ามีเลข `x` อยู่ในลำดับหรือไม่

เราสามารถ sort array ดังกล่าวเรียงจากน้อยไปมากก่อน แล้วสำหรับแต่ละคำถาม เราจะมีวิธีดังนี้
- ตอนแรก ดูตำแหน่งกลางของ array ก่อน หากตัวเลขตรงกับตัวที่ต้องการหา ก็จบการทำงาน ตอบได้ว่ามีตัวเลขดังกล่าว
- หากไม่ใช่ ให้ดูว่าตัวเลขที่เราต้องการมีค่าน้อยกว่าหรือมากกว่าตัวเลขตำแหน่งตรงกลาง
- หากตัวเลขที่เราต้องการมีค่าน้อยกว่า แสดงว่าอาจจะอยู่ทางซ้าย เราจะมาค้นหาในช่วงครึ่งซ้ายแทน แต่หากมากกว่า ให้ค้นหาในช่วงครึ่งขวา
- การค้นหาแต่ละช่วง จะใช้ดูค่าตรงกลาง แล้วเลือกครึ่งที่สมควรค้นหาเรื่อย ๆ เช่นเดียวกัน

สังเกตว่าแต่ละครั้ง array ของเราจะถูกตัดออกไปทีละครึ่ง ดังนั้น รวมแล้วจะใช้เวลาไม่เกิน `O(log n)` ในการตอบคำถามแต่ละครั้ง

### 2.2.2 การแปลง Optimization Problem เป็น Decision Problem

ปัญหาที่ต้องการให้หาค่าน้อยสุด/มากสุดบางอย่าง สามารถแปลงมาเป็นปัญหาการตัดสินใจ (ที่ต้องตอบ Yes/No) เพื่อที่จะทำให้หาคำตอบโดยการ binary search ได้ ทำให้แก้ปัญหาได้ง่ายขึ้น ยกตัวอย่างดังนี้

> มีลำดับจำนวนเต็มบวกอยู่ `n` ตัว ต้องการแบ่งเป็นช่วง ๆ โดยจะมีค่า `x` กำหนดไว้ แต่ละช่วงจะต้องมีผลรวมของสมาชิกไม่เกิน `x` ถามว่า หากเราต้องการแบ่งออกเป็นช่วงไม่เกิน `k` ช่วง เราสามารถกำหนดค่า `x` ให้น้อยสุดได้เท่าไหร่

ยกตัวอย่าง หากมีลำดับ `3, 5, 1, 2, 4` และ `k = 2` หากเรากำหนดให้ `x = 7` จะพบว่า การแบ่งโดยให้แต่ละช่วงมีผลรวมไม่เกิน `x = 7` จะต้องใช้อย่างน้อย 3 ช่วง เช่น `[3], [5], [1, 2, 4]` - ค่า `x` นี้ใช้ไม่ได้ เพราะเราต้องการแบ่งเป็นช่วงไม่เกิน `k = 2` ช่วง

หากเรากำหนดให้ `x = 8` พบว่าเราสามารถแบ่งเป็น `[3, 5], [1, 2, 4]` ซึ่งใช้เพียง `k = 2` ช่วงเท่านั้น ไม่ขัดกับเงื่อนไขโจทย์

สังเกตว่า หากเราเปลี่ยนปัญหาจาก "หาค่า `x` ที่น้อยสุดที่เป็นไปได้" เป็น "ตรวจสอบว่า ถ้าแบ่งให้แต่ละช่วงมีผลรวมไม่เกิน `x` จะแบ่งให้มีไม่เกิน `k` ช่วงได้หรือไม่" เราจะตอบปัญหาแบบหลังได้ง่ายขึ้น

การตรวจสอบว่าทำได้หรือไม่ สามารถทำได้แบบ greedy - เริ่มต้นมา ให้ช่วงแรกประกอบด้วยจำนวนตัวแรกเพียงตัวเดียว พยายามเพิ่มตัวถัดไปเรื่อย ๆ ตราบใดที่ผลรวมยังไม่เกิน `x` - ถ้าเกินแล้ว ให้เริ่มต้นช่วงใหม่ - ทำไปเรื่อย ๆ จนครบทุกตัว แล้วตรวจสอบว่าจำนวนช่วงเกิน `k` หรือไม่

เมื่อเราสามารถตรวจสอบคำตอบได้อย่างง่ายดาย การที่จะแก้ปัญหาดั้งเดิมได้นั้น ก็เพียงแค่ binary search บนค่า `x` โดยมีเงื่อนไขดังนี้
- เริ่มต้นมา พิจารณาช่วงค่า `x` ที่เป็นไปได้ตั้งแต่ `1` ถึง `INF` (เมื่อ `INF` คือ bound ผลรวมที่มากที่สุดที่เป็นไปได้ของ array ทั้ง array)
- ทดลองค่า `x` ตรงกลางช่วง หากตรวจสอบแล้วสามารถทำให้เงื่อนไขเป็นจริงได้ สังเกตว่าถ้าเราเพิ่มค่า `x` ยังไงเงื่อนไขก็ยังเป็นจริงอยู่ แต่เราต้องการค่า `x` น้อยสุด ดังนั้น เราจะพิจารณาเฉพาะช่วงคำตอบ `x` ตั้งแต่ 1 ถึงค่าดังกล่าว (เผื่อทำให้ `x` น้อยกว่านี้ได้อีก)
- หากทดลองแล้วพบว่าเงื่อนไขเป็นเท็จ นั่นแปลว่าเราจำเป็นต้องเพิ่มค่า `x` เพราะฉะนั้น เราจะพิจารณาค่า `x` ที่เป็นไปได้ ตั้งแต่ ค่าดังกล่าวบวก 1 ถึง `INF`
- เราจะแบ่งครึ่งช่วงไปเรื่อย ๆ จนกว่าจะเหลือเพียงค่าเดียว ได้เป็นคำตอบของคำถามดังกล่าว

```cpp
#include <bits/stdc++.h> // <- include everything
using namespace std;

const int N = 100010;
const long long INF = 1e18;

int n, k;
long long val[N];

bool check(long long limit)
{
    int cnt = 1;
    long long sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (val[i] > limit)
            return false;
        // เริ่มต้นช่วงใหม่ ถ้าเพิ่มตัวใหม่เข้าไปแล้วทำให้ผลรวมเกิน
        if (sum + val[i] > limit) {
            ++cnt;
            sum = 0;
        }
        sum += val[i];
    }
    return cnt <= k;
}

int main()
{
    scanf("%d%d", &k, &n);
    for (int i = 1; i <= n; ++i)
        scanf("%lld", &val[i]);
    
    long long lo = 1;
    long long hi = INF;
    while (lo < hi) {
        long long mid = (lo+hi)/2;
        if (check(mid))
            hi = mid;
        else
            lo = mid+1;
    }
    printf("%lld\n", lo);
    
    return 0;
}
```

## 2.3 Greedy

Greedy Algorithm คือขั้นตอนวิธีที่ใช้วิธีการเลือก ตัวเลือกที่ดีที่สุด เท่าที่เห็น ณ ตอนนั้นโดยไม่คำนึงถึงว่าการเลือกตัวเลือกดังกล่าวจะทำให้คำตอบนั้นดีสุดหรือไม่ โดยปกติจะใช้ Greedy Algorithm ในกรณีที่พิสูจน์ได้ว่า ถึงเลือกตัวเลือกไปแบบไม่คิดอะไรมาก ณ ตอนนั้น ทำเช่นนี้ไปเรื่อย ๆ ย่อมได้คำตอบที่ดีสุดเสมอ

ถ้าไม่นับ Greedy Algorithm อย่าง Dijkstra's Algorithm, Kruskal's Algorithm, Prim's Algorithm แล้ว ปกติ TOI ไม่ค่อยออกโจทย์ปัญหา Greedy Algorithm อื่น ๆ เพราะฉะนั้น ขอข้ามหัวข้อนี้ไป (สำหรับการหา Longest Increasing Subsequence ใน `O(n log n)` จะนำไปรวมในส่วน Dynamic Programming)

## 2.4 Dynamic Programming
_เขียนโดย szawinis_

Concept ของการทำ Dynamic Progrmaming (DP) โดยรวมแล้วคือการทำ brute force ดีๆนี่แหละ แต่ทำให้มันเร็วขึ้นโดยอาศัยบางสมบัติที่โจทย์ให้มาในการไม่คิดคำตอบซ้ำ เทคนิคนี้สามารถนำไปใช้ได้กับ optimization problem, counting problem และในบางครั้ง โจทย์แนว constructive อีกด้วย

ในการทำ DP เรามักจะนำคำตอบที่มีอยู่แล้วเพื่อมาสร้างคำตอบใหม่ซึ่งทำให้เวลาที่ใช้ในการคำนวณนั้นเร็วขึ้น โดยปกติแล้วโจทย์ที่เราใช้ DP แก้ได้จะมีคำตอบเป็นสมการ recursive ซึ่งถ้าไม่ใช้ DP จะต้องใช้เวลาการทำงานเป็น exponential time หรือมากกว่านั้นด้วยซ้ำแต่ถ้าใช้จะสามารถทำได้ใน polynomial time หรือ psuedo-polynomial time

### 2.4.1 Example: Fibonacci Numbers

ตัวอย่างที่ง่ายที่สุดในการแสดงถึงความมหัศจรรย์ของ DP คือการหาตัวเลข Fibonacci ตัวที่ `n` ซึ่งทุกคนน่าจะรู้อยู่แล้วว่าคำตอบของโจทย์ข้อนี้ถูกกำกับด้วยสมการ recursive

```
F[0] = F[1] = 1
F[i] = F[i-1] + F[i-2]
```

โดยเราจะเริ่มด้วยการเขียน recursive function ตรงๆเลย

```cpp
int fibonacci(int n) {
    if(n == 0 || n == 1) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

ถ้าพิจารณารูปด้านล่าง เราสามารถสังเกตได้ว่าถ้าเรานำสมการนี้ไปยัดใส่ recursive function เฉยๆ จะมีบาง `F[i]` ที่ถูกคิดค่าซ้ำ นอกจากนี้เวลามี่ใช้ในการทำงานเท่ากับ `O(2^n)` อีกด้วย เนื่องจากแต่ละ state นำไปสู่อีกสอง state พอวาดกราฟของ state ที่โปรแกรมเราเข้าถึง จะเห็นได้ว่ากราฟนี้เป็น binary tree ที่มีความสูงเท่ากับ `n` ซึ่งมี `2^n` โหนด

![](images/fibonacci-tree-diagram.jpg)

ในบทต่อไปเราจะมาพิจารณาวิธีที่จะหลีกเลี่ยงการคิดซ้ำที่มีอยู่หลักๆสองแบบ ซึ่งจะสามารถลดเวลาที่ใช้ในการทำงานของอัลกอริทึมนี้ลงให้เหลือ `O(n)`

### 2.4.2 Top-down DP (Memoization)

หนึ่งในวิธีการหลีกเลี่ยงการคิดคำนวณซ้ำคือการทำ memoization 

จริงๆแล้วมันก็คือการทำ recursive ที่ใส่ break condition เพิ่ม ซึ่งจะตรวจสอบว่าเราเคยเข้าถึง state นี้หรือยัง และจะ return ค่ากลับเลยโดยไม่คิดคำนวณอะไรทั้งสิ้นหากเคยมาถึง state นี้แล้ว ที่เขาเรียกกันว่า Top-down ก็เพราะว่าถ้าเราดูกราฟของ state แล้วการไล่ของเราจะเริ่มจากด้านบน แล้วค่อยๆใหลลงมาด้านล่าง

ถ้าใช้ตัวอย่าง Fibonacci เดิม โค้ดจะดูหน้าตาแบบนี้

```cpp
const int N = 1e6; // เลือกตัวเลขอะไรก็ได้ที่ใหญ่พอ
int F[N];
bool visited[N];
int fibonacci(int n) {
    if (n == 0 || n == 1)
        return 1;
    if (visited[n])
        return F[n];
    visited[n] = true;
    F[n] = fibonacci(n-1) + fibonacci(n-2);
    return F[n];
}
```

เมื่อเห็นครั้งแรกหลายคนมักจะสงสัยว่าทำไมอัลกอริทึมนี้ถึงใช้เวลา `O(n)` มองไปก็ดู้เหมือน recursive ธรรมดา การใส่ break condition เพิ่มมันสามารถทำให้เร็วขึ้นขนาดนั้นเลยหรอ? เหตุผลมีอยุ่ง่ายนิดเดียวคือ เพราะว่าเราไม่คำนวณ state ใหนซ้ำและจำนวน state ของเราเท่ากับ `n` ดังนั้นอัลกอริทึมนี้ถึงเป็น `O(n)`

อย่างไรก็ตาม วิธีนี้ค่อนข้างจะช้าในเชิงของ constant factor เนื่องมาจากธรรมชาติของ recursive function จึงมีอีกวิธีหนึ่งที่สามารถหาคำตอบใน Big O เดียวกัน แต่ด้วย constant factor ที่น้อยกว่า

### 2.4.3 Bottom-up DP

อีกวิธีที่คนมักใช้กันก็คือ Bottom-up ซึ่งเป็นการหาคำตอบของ state ที่อยู่ด้านล่างก่อน (ในกราฟของ state) โดยจะเริ่มจาก base case ที่รู้คำตอบอยู่แล้ว แล้วจะค่อยๆสร้างของ state ที่ใหญ่ขึ้นไปเรื่อยๆ

โค้ดของ Fibonacci ใช้ Bottom-up จะดูหน้าตาประมาณนี้

```cpp
int fibonacci(int n) {
    int F[n+1];
    F[0] = F[1] = 1;
    for (int i = 2; i <= n; i++)
        F[i] = F[i-1] + F[i-2];
    return F[n];
}
```

เวลาการทำงานของอัลกอริทึมนี้แน่นอนคือ `O(n)` ซึ่งดูได้ง่ายมากจาก for loop อันเดียว นอกจากนี้ยังทำเวลาได้ดีกว่า Top-down อีกด้วย (ในเกือบทุกกรณี) เนื่องจาก constant factor ดีกว่า

### 2.4.4 ใช้ Top-down หรือ Bottom-up ดี?

ที่ผมเคยเจอมาแทบจะไม่มี DP ข้อใหนที่ใช้ได้แค่อย่างใดอย่างหนึ่ง ส่วนมากแล้ววิธีการเลือกใช้มักจะเป็นที่ความยากง่ายในการ implement และ time limit ถ้าหาก time limit ค่อนข้างต่ำและมีโอกาสสูงที่โค้ดเราจะเจอ time limit exceeded ก็แนะนำให้ใช้ Bottom-up เนื่องจาก constant factor ดีกว่า อย่างไรก็ตาม ถ้าเราไม่สามารถไล่ state จากล่างขึ้นบนได้ง่ายๆ หรือไม่มี pattern ที่แน่ชัด ก็ควรจะใช้ Top-down เพราะจะได้ไม่ต้องปวดหัวกับการที่จะต้องมาคิดว่าต้องไล่อะไรยังไง แค่ยัดๆใส่ recursive function ไปเลยแล้วทำ memoization เดี๋ยวก็ผ่าน

มากไปกว่านั้นการทำ DP แบบ Top-down สามารถใช้หลีกเลี่ยงการที่ต้องคำนวณทุก state เพราะมีโจทย์อยู่หลายข้อเลยทีเดียวที่่ไม่จำเป็นต้องไปให้ครบทุก state ก็ได้ ดังนั้น ถ้าเรารู้ว่าอาจจะไม่ได้ไปครบทุก state ก็ควรจะใช้ Top-down เพื่อทำให้ทั้ง time และ memory ลดลง

### 2.4.5 Example: Coin Change Problem

เราจะมาดูขั้นตอนในการแก้โจทย์ DP โดยจะใช้ปัญหา Coin Change เป็นตัวอย่าง

> กำหนดจำนวนเต็ม `n`, `k` จำนวนประเภทของเหรียญ โดยจะมีลำดับ `C` โดยที่ `C[i]` บ่งบอกถึงค่าของเหรียญประเภทที่ `i` สมมุติว่าสำหรับแต่ละประเภทเรามีเหรียญไม่จำกัด จะต้องใช้อย่างน้อยกี่เหรียญ (จะเอากี่ประเภทมาใช้ด้วยกันก็ได้) ถึงจะสามารถจ่ายของราคา `k` ได้โดยไม่มีเงินทอน (เท่ากับ `k` พอดี)

สิ่งแรกที่เราต้องทำเมื่อเราคิดว่าเจอโจทย์แนว DP คือสร้างสมการ recursive กำกับคำตอบ ถ้าเราสามารถสร้างสมการ recursive นี้ได้ เราก็สามารถที่จะใช้ Top-down หรือ Bottom-up ก็ได้เพื่อลดเวลาที่ใช้ในการทำงาน แต่ก่อนที่จะไปถึงตรงนั้น เรามีปัญหาอยู่คือยังคิดสมการไม่ออกเลย!

การสร้างสมการขึ้นมาเป็นสิ่งที่ต้องอาศัยการฝึกฝนอย่างสูง โดยเฉพาะข้อที่ยากๆและต้องใช้สมการแปลกๆ
อย่างไรก็ตาม มันจะง่ายขึ้นถ้าเราคิดในเชิงสามขั้นตอนนี้

1. หาว่า state เราควรจะบ่งบอกถึงอะไร
2. หาว่า แต่ละ state มันใช้คำตอบจาก state ใหนได้บ้างที่จะมาใช้ในคำตอบของ state นี้
3. หาว่า เราจะคำนวณคำตอบของ state นี้จาก state อื่นอย่างไร

เราจะมาดูว่าเราจะสามขั้นตอนนี้ในการแก้ปัญหา coin change ได้อย่างไร

อย่างแรกเลยคือเราต้องหาว่า state เราจะบ่งบอกถึงอะไร เราก็ถามตัวเองว่า ในโจทย์ข้อนี้ เขามีข้อกำหนดอะไรมาให้เราบ้าง? ในที่นี้โจทย์เอ่ยถึงสองอย่างที่น่าสนใจคือจำนวณของเหรียญกับผลรวมค่าของเหรียญ ถ้าเราลองใช้จำนวณของเหรียญเป็น state แล้ว `dp[จำนวณเหรียญ]` จะบ่งบอกถึงอะไรล่ะ? ผลรวมน้อยสุดที่เป็นไปได้? ทุกผลรวมที่เป็นไปได้? ทั้งสองอย่างนี้ไม่เหมาะสมกับคำตอบที่เราอยากได้เลย เพราะอันแรกไม่สามารถนำไปใช้ได้ และอันที่สองดูจะใช้เวลามากเกินไป ณ จุดนี้เราไม่รู้เลยว่าจะไปต่อยังไงเพราะว่าเราไม่สามารถนิยาม `dp[จำนวณเหรียญ]` ให้เหมาะสมกับโจทย์ได้ ดังนั้นเราก็ต้องถอยกลับไปลองใช้ผลรวมค่าของเหรียญมาเป็น state

ถ้าใช้ผลรวมค่าของเหรียญจะเกิดอะไรขึ้นล่ะ? อย่างแรกเลยเราก็สามารถที่จะนิยาม `dp[ผลรวมค่าของเหรียญ]` ให้เท่ากับคำตอบเลย ซึ่งคือจำนวณเหรียญน้อยสุดที่เป็นไปได้ สิ่งสุดท้ายที่เราต้องหาคือจะคำนวณคำตอบของ state `dp[ผลรวมค่าของเหรียญ]` จาก state ใหนได้บ้าง กล่าวอักนัยหนึ่งคือ จาก state ก่อนหน้า เราจะมาหา state นี้ได้อย่างไร ถ้าเรามีผลรวมค่าของเหรียญเท่ากับ `y` และต้องการให้มันเท่ากับ `x` ที่แน่นอนคือ `x = y + C[i]` เนื่องจากเราต้องใช้หนึ่งเหรียญในการเพิ่มผลรวมค่าของเหรียญ ถ้าเราย้ายข้างสมการ เราก็จะได้ว่า `y = x - C[i]` โดยที่ `C[i]` นั้นเป็นค่าของเหรียญชนิดหนึ่งที่ให้มาในโจทย์ มากไปกว่านั้น สำหรับ `x` ใดๆ เราสามารถใช้ทุก `i` ที่เป็นไปได้เพื่อหาแต่ละค่า `y`  

ดังนั้นสมการกำกับคำตอบของข้อนี้คือ

```
dp[0] = 0
dp[x] = min(dp[x - C[i]] + 1), 1 <= i <= n, C[i] <= x
```

โดยที่ `x` คือราคาของใน state นั้นๆ และคำตอบสุดท้ายคือ `dp[k]`

ถ้าเราเขียน Top-down ก็จะดูหน้าตาแบบนี้

```cpp
const int N = 1e6, INF = INT_MAX;
int n, C[N], dp[N];
bool visited[N];
int coin_change(int x) {
    if (x == 0)
        return 0;
    if (visited[x])
        return dp[x];
    visited[x] = true;
    dp[x] = INF;
    for (int i = 1; i <= n; i++) {
        if (C[i] <= x)
            dp[x] = min(solve(x - C[i]) + 1, dp[x]);
    }
    return dp[x];
}
// answer: coin_change(k)
```

แต่ถ้าเราใช้ Bottom-up ก็จะเป็นแบบนี้

```cpp
const int N = 1e6, INF = INT_MAX;
int n, C[N], dp[N];
int coin_change(int k) {
    fill(dp, dp+N, INF);
    dp[0] = 0;
    for (int x = 1; x <= k; x++) {
        for (int i = 1; i <= n; i++) {
            if (C[i] <= x)
                dp[x] = min(dp[x - C[i]] + 1, dp[x]);
        }
    }
    return dp[k];
}
```
ทั้่งคู่ทำงานได้ภายใน `O(nk)` ซึ่งถือว่าเป็น pseudo-polynomial time

### 2.4.6 Multi-dimensional DP Example: Maximum Monotonic Path

ที่ผ่านมา เราอยู่กับแค่สมการ DP ที่มีอยู่มิติเดียว เราจะมาลองพิจารณาโจทย์ข้อหนึ่งที่ไม่ได้ใช้มิติเดียวแก้ โดยจะใช้ปัญหา Maximum Monotonic Path เป็นตัวอย่าง

> กำหนดจำนวนเต็ม `n` และตาราง `n*n` เหรียกว่า `a[i][j]` เราจะเริ่มจากช่องที่ `a[1][1]` และเดินไปยัง `a[n][n]` โดยที่จะสามารถขยับได้สองทางจาก `a[i][j]` คือไปยัง `a[i+1][j]` และ `a[i][j+1]` เท่านั้น หลังจากที่เดินเสร็จแล้ว เราจะหาผลรวมของ `a[i][j]` ที่ได้ใช้เดิน ถามว่าผลรวมมากที่สุดคือเท่าใด

ถ้าต้องการใช้ หนึ่งมิติจริงๆก็ทำได้ โดยต้องทำการ compress ตารางแต่ที่จริงแล้ววิธีแบบนั้นมันยากกว่าใช้สองมิติตรงๆ ในข้อนี้เราจะให้ state ของเราเป็นผลรวมมากที่สุดหาเดินมาช่องที่ `a[i][j]` และจะมาถึง `a[i][j]` ได้จาก `a[i-1][j]` และ `a[i][j-1]`

ดังนั้นเราก็ได้สมการ DP หน้าตาแบบนี้

`dp[1][1] = a[1][1]`<br>
`dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i]`

โค้ดแบบ Top-Down:
```cpp
const int N = 1e3+1;
int a[N][N], dp[N][N];
bool visited[N][N];
int calculate_dp(int i, int j) {
    if (i == 1 && j == 1)
        return a[i][j];
    if (visited[i][j])
        return dp[i][j];
    visited[i][j] = true;
    dp[i][j] = max(calculate_dp(i-1, j), calculate_dp(i, j-1)) + a[i][j];
    return dp[i][j];
}
// answer: calculate_dp(n, n)
```

โค้ดแบบ Bottom-up:
```cpp
const int N = 1e3+1;
int a[N][N], dp[N][N];
int solve(int n) {
    dp[1][1] = a[1][1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == 1 && j == 1)
                continue;
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i][j];
        }
    }
    return dp[n][n];
}
```
อัลกอริทึมนี้วิเคราะห์ big O ได้ง่ายๆเลยเนื่องจากเป็นแค่ for loop สองชั้น เท่ากับ `O(n^2)`