# Table of Contents

**2. Problem Solving Paradigms**
  - 2.1 Brute Force
    - 2.1.1 Iterative Complete Search
    - 2.1.2 Recursive Complete Search
    - 2.1.3 Simulation
  - 2.2 Divide and Conquer
    - 2.2.1 Binary Search
    - 2.2.2 การแปลง Optimization Problem เป็น Decision Problem
  - 2.3 Greedy
  - 2.4 Dynamic Programming
    - 2.4.1 Top-down Dynamic Programming (Memoization)
    - 2.4.2 Bottom-up Dynamic Programming
    - 2.4.3 Steps to solve Dynamic Programming problems
    - 2.4.4 Multi-dimensional DP
    - 2.4.5 Prefix/Suffix Dynamic Programming
    - 2.4.6 LIS-style Dynamic Programming
    - 2.4.7 Substring Dynamic Programming
    - 2.4.8 Partitioning Problem
    - 2.4.9 DP on Directed Acyclic Graph (DAG)
    - 2.4.10 Bitmask Dynamic Programming

# 2. Problem Solving Paradigms

## 2.1 Brute Force

Brute Force เป็นวิธีการแก้ปัญหาที่ง่ายที่สุด เพราะไม่จำเป็นต้องคิดวิธีที่ดีอะไรมาก เพียงแค่ทดลองทุกคำตอบ/ทุกกรณีที่เป็นไปได้ แล้วตอบคำตอบที่ดีที่สุด (หรือตอบจำนวนวิธีที่เป็นไปได้ หากโจทย์ถามหาจำนวนวิธีในการทำอะไรบางอย่าง) จะหนักที่การ implement ซะมากกว่า

ถึงโจทย์ส่วนใหญ่จะให้คะแนนวิธีนี้น้อย เราควรศึกษาและฝึก implement Brute Force ให้ดี ๆ เพราะหากหาวิธีที่ดีไม่ได้ การทำ Brute Force ก็อาจจะช่วยให้ได้คะแนนได้บางส่วน

### 2.1.1 Iterative Complete Search

โจทย์บางข้อสามารถ Brute Force ได้โดยการทดลองลูปบนคำตอบทั้งหมดที่เป็นไปได้ โดยอาจจะลูปหลายชั้น เช่น

> กำหนดลำดับตัวเลขมาให้ `n` ตัว ให้เลือกตัวเลขสองตัวที่มีค่าต่างกันน้อยที่สุดที่เป็นไปได้

วิธีหนึ่งที่ทำได้ คือลูปสองชั้นเพื่อทดลองเลือกตัวเลขสองตัวทุกแบบที่เป็นไปได้ หาวิธีการเลือกที่ได้ค่าแตกต่างกันน้อยที่สุดแล้วตอบ

> กำหนดจำนวนเต็ม `A` และ `B` ให้ จงหาจำนวนเต็มบวก `x` และ `y` ทุกคู่ที่ตรงตามเงื่อนไข `x+y = A` และ `x*y = B`

ใช้การทดลองลูปสองชั้นเพื่อทดลองค่า `x`, `y` ทั้งหมดที่เป็นไปได้ (ไม่เกิน `A` หรือ `B`) แล้วตรวจสอบเงื่อนไขทั้งสองเงื่อนไข ถ้าตรงเงื่อนไขก็ตอบคู่นั้น วิธีนี้จะใช้เวลา `O(min(A, B)^2)`

สังเกตว่าความจริงแล้วเราไม่จำเป็นต้องลูปค่า `y` ก็ได้ เพราะหากเลือกค่า `x` แล้ว เราสามารถสรุปได้ทันทีว่า `y = A-x` ตามสมการแรก สิ่งที่ต้องทำมีเพียงแค่การตรวจสอบเงื่อนไข `x*y = B` ว่าเป็นจริงหรือไม่ วิธีนี้จะใช้เวลา `O(min(A, B))`

### 2.1.2 Recursive Complete Search

โจทย์บางข้อจำเป็นต้องทดลองวิธีเป็นจำนวนมาก และไม่สามารถใช้ลูปหลายชั้นในการแก้ได้ ดังนั้นจึงต้องเขียน recursive function เพื่อทดลองเลือกทุกวิธีที่เป็นไปได้แทน

**Perket - COCI 2008/2009, Contest #2**

> ต้องการทำอาหาร มีส่วนผสมให้ทั้งหมด `n` ชิ้น (`n <= 10`) โดยส่วนผสมแต่ละชิ้นจะมีค่าความเปรี้ยวและค่าความขม ให้เลือกส่วนผสมมาทำอาหาร (เลือกกี่ชิ้นก็ได้ แต่ต้องอย่างน้อย 1 ชิ้น) เมื่อทำอาหาร จะได้อาหารที่มีค่าความเปรี้ยวเท่ากับผลคูณของค่าความเปรี้ยวของส่วนผสมที่เลือกมา ส่วนค่าความขมจะเท่ากับผลบวกของค่าความขมของส่วนผสมที่เลือกมา ให้หาวิธีเลือกโดยให้ความต่างระหว่างค่าความขมกับค่าความเปรี้ยวน้อยที่สุดเท่าที่เป็นไปได้
>

สังเกตว่าเราต้องการทดลองเลือกทุกสับเซตที่เป็นไปได้ (ยกเว้นเซตว่าง) แล้วหาสับเซตที่มีค่าความต่างน้อยที่สุด วิธีการหนึ่งที่เป็นไปได้คือการเลือกตัดสินใจว่า ชิ้นที่ 1 จะเอาหรือไม่ ชิ้นที่ 2 จะเอาหรือไม่, ..., ชิ้นที่ `n` จะเอาหรือไม่

ในการทดลอง เราสร้าง array ของ `bool` ชื่อ `picked` ขึ้นมา โดยนิยามให้ `picked[i]` เป็น `true` ถ้าเลือกใช้ส่วนผสมชิ้นที่ `i` และเป็น `false` ถ้าไม่เลือกใช้

ต่อมา กำหนดฟังก์ชัน recursive ชื่อ `pick(i)` ซึ่งจะทำหน้าที่กำหนดค่าให้ `picked[i]` เป็น `true`, เรียก `pick(i+1)` เพื่อทำการเลือกส่วนผสมชิ้นถัด ๆ ไปทุกแบบที่เป็นไปได้ เมื่อ return กลับมาแล้วจึงกำหนดค่าให้ `picked[i]` เป็น `false` แล้วเรียก `pick(i+1)` เพื่อทดลองทุกความเป็นไปได้เช่นเดียวกัน

ในกรณีที่เรียก `pick(n+1)` จะถือว่าทดลองเลือกของมาแล้ววิธีหนึ่งตามที่ระบุใน array `picked`, ฟังก์ชันจะทำการคำนวณค่าความต่าง พร้อมเช็คเงื่อนไขเพื่อให้มั่นใจว่าไม่ได้เลือกเซตว่างมา หากค่าความต่างน้อยกว่าค่าความต่างน้อยสุดที่เคยเก็บไว้ ก็ให้จดคำตอบใหม่

ดูโค้ดตัวอย่างด้านล่าง

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20;
const int INF = 1e9;

int n;
int sour[N], bitter[N];
bool picked[N];
int ans = INF;

void pick(int i)
{
    if (i <= n) {
        picked[i] = true;
        pick(i+1);
        picked[i] = false;
        pick(i+1);
    } else { // i == n+1
        int total_sour = 1, total_bitter = 0, count_used = 0;
        for (int j = 1; j <= n; ++j) {
            if (picked[j]) {
                ++count_used;
                total_sour *= sour[j];
                total_bitter += bitter[j];
            }
        }
        if (count_used != 0)
            ans = min(ans, abs(total_sour - total_bitter));
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d%d", &sour[i], &bitter[i]);
    pick(1);
    printf("%d\n", ans);
    
    return 0;
}
```

**Bond - COCI 2006/2007, Contest #1**

> กำหนดตารางขนาด `n*n` ให้ แต่ละช่องมีจำนวนเต็มกำกับอยู่ แสดงถึงความน่าจะเป็น มีค่าตั้งแต่ 0 ถึง 100 ให้เลือกตัวเลขในตารางมา `n` ตัว โดยที่ตัวเลขที่เลือกจะต้องไม่มีตัวใดอยู่ในแถวเดียวกันหรือหลักเดียวกัน จงหาว่าจะสามารถเลือกให้ได้ผลคูณของความน่าจะเป็นมากที่สุดเท่าใด (ตอบเป็นทศนิยม 6 หลัก มีค่าตั้งแต่ 0 ถึง 100)

การเลือกที่ตรงตามเงื่อนไขโจทย์นั้น แต่ละแถวจะมีคอลัมน์ที่ถูกเลือกคอลัมน์หนึ่งพอดี และจะไม่มีคอลัมน์ใดถูกเลือกซ้ำกัน หากแก้โจทย์ข้อนี้โดยใช้ Brute Force เราอาจทำได้โดยการเขียนฟังก์ชันเพื่อทดลองเลือกคอลัมน์ให้กับแต่ละแถว แล้วตรวจสอบว่ามีการเลือกคอลัมน์ซ้ำกันหรือไม่ ถ้าไม่มีการเลือกซ้ำกัน ให้จดคำตอบที่ดีที่สุดที่เป็นไปได้ (ผลคูณที่มากสุดที่เป็นไปได้)

สังเกตว่า เราไม่จำเป็นต้องเช็คเงื่อนไขตอนจบเพียงอย่างเดียวก็ได้ แต่ตรวจสอบเงื่อนไขขณะที่เลือกได้เลย ถ้าพบว่าเลือกแล้วผิดเงื่อนไขก็ให้ข้ามตัวเลือกนั้น วิธีนี้เรียกว่า Recursive Backtracking

โค้ดตัวอย่างดังนี้

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 21;

int n;
double A[N][N];
bool used[N];
double ans = 0;

// i = current row, prod = product of picked values
void solve(int i, double prod) {
    if (i == n+1) {
        ans = max(ans, prod);
        return;
    }
    // try picking each column
    for (int j = 1; j <= n; ++j) {
        if (used[j]) // can't pick already-used column
            continue;
        // if can pick, try picking then call recursively
        used[j] = true;
        solve(i+1, prod*A[i][j]);
        used[j] = false;
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            scanf("%lf", &A[i][j]);
            A[i][j] /= 100; // must convert to real number in [0, 1]
        }
    }
    solve(1, 1.0);
    printf("%.6f\n", ans*100.0); // must convert back to range [0, 100]
    return 0;
}
```

**N-Queen Problem**

> มีกระดานหมากรุกขนาด `n*n` ให้วาง Queen ทั้งหมด `n` ตัวโดยที่ Queen แต่ละตัวต้องไม่ attack Queen ตัวอื่น (จะ attack ก็ต่อเมื่ออยู่ในแถว/คอลัมน์/แนวทแยงเดียวกันเท่านั้น)

แต่ละแถว จะต้องเลือกตำแหน่งให้ queen อยู่ ณ คอลัมน์ใดคอลัมน์หนึ่ง โดยเมื่อเลือกเสร็จแล้ว ต้องตรวจสอบว่าแต่ละคอลัมน์ถูกเลือกเพียงครั้งเดียวเท่านั้น นอกจากนี้ queen แต่ละตัวต้องไม่อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่น ๆ ด้วย หากไม่ขัดเงื่อนไขก็สามารถตอบวิธีการวางดังกล่าวได้

สังเกตว่าสามารถทำคล้าย ๆ ข้อ Bond ได้ นั่นคือทำ Recursive Backtracking - ระหว่างเลือก ต้องตรวจสอบว่าไม่ได้ใช้คอลัมน์ซ้ำกับ queen ตัวอื่น และไม่ได้อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่นเช่นกัน

### 2.1.3 Simulation

โจทย์บางข้อกำหนดสถานการณ์มาให้ แล้วคุณต้องตอบคำถามตามที่โจทย์กำหนด วิธีที่ง่ายที่สุดวิธีหนึ่งคือการ implement โค้ดเพื่อจำลองสถานการณ์แล้วตอบคำถาม

> กำหนดลำดับจำนวนเต็ม `1` ถึง `n` มาให้ ให้ทำการ sort array ดังกล่าวด้วย bubble sort - มีคำถามมาให้ `q` คำถาม แต่ละคำถามถามว่า ใน bubble sort pass ที่ `k` ตัวเลข `x` อยู่ที่ตำแหน่งใด

เราอาจจะสร้าง array 2 มิติขึ้นมาเพื่อเก็บสภาพของ array หลังการ bubble sort แต่ละรอบ แล้วตอบคำถามแต่ละคำถาม

## 2.2 Divide and Conquer

แนวคิดหลัก ๆ ของ Divide and Conquer คือ แบ่งปัญหาออกเป็นหลายส่วนที่เท่า ๆ กัน ใช้อัลกอริทึมเดิมแก้ปัญหาย่อย ๆ ซ้ำแบบ recursive แล้วหาวิธีรวมคำตอบเข้าด้วยกัน เป็นคำตอบของปัญหาใหญ่ (โดยส่วนใหญ่ จะแบ่งออกเป็น 2 ส่วนเท่า ๆ กัน)

ยกตัวอย่างอัลกอริทึม Divide and Conquer เช่น Merge Sort ที่ใช้การ sort array ครึ่งแรกกับครึ่งหลังแยกกัน แล้วค่อยนำ array ทั้งสองมารวมกัน เนื่องจากว่ามีการแบ่งครึ่งลงไปทั้งหมด `O(log n)` ชั้น แต่ละชั้นจะต้องจัดการกับสมาชิกของ array เพื่อทำการรวม array - รวมทั้งหมด `O(n)` ตัว ทำให้เวลาการทำงานของ merge sort เป็น `O(n log n)`

ในการแข่งขัน TOI ปกติจะไม่ค่อยเจอโจทย์ Divide and Conquer ท่าแปลก ๆ มาก ยกเว้นการ Binary Search บนปัญหา Optimization Problem ที่ถูกแปลงเป็น Decision Problem ซึ่งพบได้บ่อยมาก ควรศึกษาไว้

### 2.2.1 Binary Search

> กำหนดลำดับจำนวนให้ทั้งหมด `n` ตัว มีคำถามให้ `q` คำถาม แต่ละคำถาม ให้หาว่ามีเลข `x` อยู่ในลำดับหรือไม่

เราสามารถ sort array ดังกล่าวเรียงจากน้อยไปมากก่อน แล้วสำหรับแต่ละคำถาม เราจะมีวิธีดังนี้
- ตอนแรก ดูตำแหน่งกลางของ array ก่อน หากตัวเลขตรงกับตัวที่ต้องการหา ก็จบการทำงาน ตอบได้ว่ามีตัวเลขดังกล่าว
- หากไม่ใช่ ให้ดูว่าตัวเลขที่เราต้องการมีค่าน้อยกว่าหรือมากกว่าตัวเลขตำแหน่งตรงกลาง
- หากตัวเลขที่เราต้องการมีค่าน้อยกว่า แสดงว่าอาจจะอยู่ทางซ้าย เราจะมาค้นหาในช่วงครึ่งซ้ายแทน แต่หากมากกว่า ให้ค้นหาในช่วงครึ่งขวา
- การค้นหาแต่ละช่วง จะใช้ดูค่าตรงกลาง แล้วเลือกครึ่งที่สมควรค้นหาเรื่อย ๆ เช่นเดียวกัน

สังเกตว่าแต่ละครั้ง array ของเราจะถูกตัดออกไปทีละครึ่ง ดังนั้น รวมแล้วจะใช้เวลาไม่เกิน `O(log n)` ในการตอบคำถามแต่ละครั้ง

### 2.2.2 การแปลง Optimization Problem เป็น Decision Problem

ปัญหาที่ต้องการให้หาค่าน้อยสุด/มากสุดบางอย่าง สามารถแปลงมาเป็นปัญหาการตัดสินใจ (ที่ต้องตอบ Yes/No) เพื่อที่จะทำให้หาคำตอบโดยการ binary search ได้ ทำให้แก้ปัญหาได้ง่ายขึ้น ยกตัวอย่างดังนี้

> มีลำดับจำนวนเต็มบวกอยู่ `n` ตัว ต้องการแบ่งเป็นช่วง ๆ โดยจะมีค่า `x` กำหนดไว้ แต่ละช่วงจะต้องมีผลรวมของสมาชิกไม่เกิน `x` ถามว่า หากเราต้องการแบ่งออกเป็นช่วงไม่เกิน `k` ช่วง เราสามารถกำหนดค่า `x` ให้น้อยสุดได้เท่าไหร่

ยกตัวอย่าง หากมีลำดับ `3, 5, 1, 2, 4` และ `k = 2` หากเรากำหนดให้ `x = 7` จะพบว่า การแบ่งโดยให้แต่ละช่วงมีผลรวมไม่เกิน `x = 7` จะต้องใช้อย่างน้อย 3 ช่วง เช่น `[3], [5], [1, 2, 4]` - ค่า `x` นี้ใช้ไม่ได้ เพราะเราต้องการแบ่งเป็นช่วงไม่เกิน `k = 2` ช่วง

หากเรากำหนดให้ `x = 8` พบว่าเราสามารถแบ่งเป็น `[3, 5], [1, 2, 4]` ซึ่งใช้เพียง `k = 2` ช่วงเท่านั้น ไม่ขัดกับเงื่อนไขโจทย์

สังเกตว่า หากเราเปลี่ยนปัญหาจาก "หาค่า `x` ที่น้อยสุดที่เป็นไปได้" เป็น "ตรวจสอบว่า ถ้าแบ่งให้แต่ละช่วงมีผลรวมไม่เกิน `x` จะแบ่งให้มีไม่เกิน `k` ช่วงได้หรือไม่" เราจะตอบปัญหาแบบหลังได้ง่ายขึ้น

การตรวจสอบว่าทำได้หรือไม่ สามารถทำได้แบบ greedy - เริ่มต้นมา ให้ช่วงแรกประกอบด้วยจำนวนตัวแรกเพียงตัวเดียว พยายามเพิ่มตัวถัดไปเรื่อย ๆ ตราบใดที่ผลรวมยังไม่เกิน `x` - ถ้าเกินแล้ว ให้เริ่มต้นช่วงใหม่ - ทำไปเรื่อย ๆ จนครบทุกตัว แล้วตรวจสอบว่าจำนวนช่วงเกิน `k` หรือไม่

เมื่อเราสามารถตรวจสอบคำตอบได้อย่างง่ายดาย การที่จะแก้ปัญหาดั้งเดิมได้นั้น ก็เพียงแค่ binary search บนค่า `x` โดยมีเงื่อนไขดังนี้
- เริ่มต้นมา พิจารณาช่วงค่า `x` ที่เป็นไปได้ตั้งแต่ `1` ถึง `INF` (เมื่อ `INF` คือ bound ผลรวมที่มากที่สุดที่เป็นไปได้ของ array ทั้ง array)
- ทดลองค่า `x` ตรงกลางช่วง หากตรวจสอบแล้วสามารถทำให้เงื่อนไขเป็นจริงได้ สังเกตว่าถ้าเราเพิ่มค่า `x` ยังไงเงื่อนไขก็ยังเป็นจริงอยู่ แต่เราต้องการค่า `x` น้อยสุด ดังนั้น เราจะพิจารณาเฉพาะช่วงคำตอบ `x` ตั้งแต่ 1 ถึงค่าดังกล่าว (เผื่อทำให้ `x` น้อยกว่านี้ได้อีก)
- หากทดลองแล้วพบว่าเงื่อนไขเป็นเท็จ นั่นแปลว่าเราจำเป็นต้องเพิ่มค่า `x` เพราะฉะนั้น เราจะพิจารณาค่า `x` ที่เป็นไปได้ ตั้งแต่ ค่าดังกล่าวบวก 1 ถึง `INF`
- เราจะแบ่งครึ่งช่วงไปเรื่อย ๆ จนกว่าจะเหลือเพียงค่าเดียว ได้เป็นคำตอบของคำถามดังกล่าว

```cpp
#include <bits/stdc++.h> // <- include everything
using namespace std;

const int N = 100010;
const long long INF = 1e18;

int n, k;
long long val[N];

bool check(long long limit)
{
    int cnt = 1;
    long long sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (val[i] > limit)
            return false;
        // เริ่มต้นช่วงใหม่ ถ้าเพิ่มตัวใหม่เข้าไปแล้วทำให้ผลรวมเกิน
        if (sum + val[i] > limit) {
            ++cnt;
            sum = 0;
        }
        sum += val[i];
    }
    return cnt <= k;
}

int main()
{
    scanf("%d%d", &k, &n);
    for (int i = 1; i <= n; ++i)
        scanf("%lld", &val[i]);
    
    long long lo = 1;
    long long hi = INF;
    while (lo < hi) {
        long long mid = (lo+hi)/2;
        if (check(mid))
            hi = mid;
        else
            lo = mid+1;
    }
    printf("%lld\n", lo);
    
    return 0;
}
```

## 2.3 Greedy

Greedy Algorithm คือขั้นตอนวิธีที่ใช้วิธีการเลือก ตัวเลือกที่ดีที่สุด เท่าที่เห็น ณ ตอนนั้นโดยไม่คำนึงถึงว่าการเลือกตัวเลือกดังกล่าวจะทำให้คำตอบนั้นดีสุดหรือไม่ โดยปกติจะใช้ Greedy Algorithm ในกรณีที่พิสูจน์ได้ว่า ถึงเลือกตัวเลือกไปแบบไม่คิดอะไรมาก ณ ตอนนั้น ทำเช่นนี้ไปเรื่อย ๆ ย่อมได้คำตอบที่ดีสุดเสมอ

ถ้าไม่นับ Greedy Algorithm อย่าง Dijkstra's Algorithm, Kruskal's Algorithm, Prim's Algorithm แล้ว ปกติ TOI ไม่ค่อยออกโจทย์ปัญหา Greedy Algorithm อื่น ๆ เพราะฉะนั้น ขอข้ามหัวข้อนี้ไป

## 2.4 Dynamic Programming

**Dynamic Programming (DP)** คือการแก้ปัญหาที่มีลักษณะคล้าย ๆ การเขียนฟังก์ชัน brute force ที่มีการ return คำตอบ เพียงแต่อาศัยคุณสมบัติพิเศษของปัญหา เพื่อทำให้การคิดคำนวณทำได้ไวขึ้น หลัก ๆ แล้วมีสองอย่าง ได้แก่
1) **Optimal Substructure** หากสร้างคำตอบของปัญหาใหญ่ได้ คำตอบของปัญหาย่อยย่อมดีที่สุดด้วย
2) **Overlapping Subproblems** ปัญหาใหญ่สามารถแบ่งเป็นปัญหาย่อยต่าง ๆ ได้ แล้วปัญหาย่อยต่าง ๆ หากแบ่งออกไปอีก อาจจะแบ่งได้ปัญหาย่อยที่ซ้ำกัน

ถ้าเจอปัญหาซ้ำกัน เราไม่จำเป็นต้องคิดคำตอบซ้ำ ทำให้สามารถคำนวณคำตอบของปัญหาทั้งหมดได้เร็วขึ้น เทคนิค Dynamic Programming นี้สามารถนำไปใช้ได้กับ Optimization Problem, Counting Problem และในบางครั้ง โจทย์แนว constructive อีกด้วย

**Fibonacci Numbers**

ตัวอย่างที่ง่ายที่สุดคือการหาตัวเลข Fibonacci ตัวที่ `n` โดยตัวเลข Fibonacci มีนิยามดังนี้

```
F[0] = F[1] = 1
F[n] = F[n-1] + F[n-2]
```

ปกติแล้ว หากเขียนเป็น recursive function จะได้โค้ดดังนี้

```cpp
int fibonacci(int n) {
    if (n == 0 || n == 1)
        return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

พิจารณารูปด้านล่าง สังเกตได้ว่าหากคำนวณโดยใช้ recursive function จะมีค่า `F[i]` บางค่าที่ถูกคำนวณซ้ำ รวมแล้วพบว่าจะใช้เวลาในการทำงานเป็น `O(2^n)` อีกด้วย (ประมาณได้จากการที่แต่ละ node จะต้องแตกออกเป็น 2 node - เนื่องจากมีทั้งหมด `n` node จึงใช้เวลามากประมาณ `O(2^n)`)

![](images/fibonacci-tree-diagram-colour.jpg)

หัวข้อถัดไป จะกล่าวถึงวิธีการหลีกเลี่ยงการคิดข้อมูลซ้ำ ทำให้สามารถแก้ปัญหา Fibonacci ได้ในเวลา `O(n)`

### 2.4.1 Top-down Dynamic Programming (Memoization)

หนึ่งในวิธีการหลีกเลี่ยงการคิดคำนวณซ้ำคือการทำ memoization 

นั่นคือ การเขียนฟังก์ชัน recursive ที่ใส่ break condition เพิ่มเติม โดยตรวจสอบว่าเคยเข้าถึง state นั้นหรือยัง หากพบว่าเคยเข้าถึง state นั้นแล้ว ก็จะ return คำตอบที่เคยคำนวณไว้ทันทีเลย

สังเกตว่าเราจะเรียกฟังก์ชันเพื่อแก้ปัญหาใหญ่ก่อน แล้วฟังก์ชันนั้นจะเรียกตนเองแบบ recursive เพื่อแก้ปัญหาย่อยเรื่อย ๆ ดังนั้นวิธีการ implement DP แบบดังกล่าวจึงเรียกว่าเป็นแบบ Top-down

ตามตัวอย่างการคำนวณค่า Fibonacci โค้ดจะมีลักษณะดังนี้

```cpp
int F[N];
bool visited[N];

int fibonacci(int n) {
    if (n == 0 || n == 1)
        return 1;
    if (visited[n]) // return if already computed
        return F[n];
    visited[n] = true; // set as "already computed"
    F[n] = fibonacci(n-1) + fibonacci(n-2); // remember answer
    return F[n];
}
```

สังเกตว่าอัลกอริทึมดังกล่าวจะใช้เวลา `O(n)` เพราะการใส่ break condition ทำให้มี state เพียง `O(n)` state เท่านั้น สำหรับค่า `n` แต่ละค่า หากเราทราบคำตอบของค่า `n` ที่น้อยกว่าอยู่แล้ว จะสามารถคำนวณคำตอบได้ใน `O(1)` (นั่นคือนำคำตอบมาบวกกันเฉย ๆ)

อย่างไรก็ตาม การ implement แบบ top-down โค้ดอาจจะทำงานได้ช้า เนื่องจาก constant factor ในการจัดการการเรียกฟังก์ชันของระบบสูง

### 2.4.2 Bottom-up Dynamic Programming

อีกวิธีที่คนมักใช้กันก็คือ Bottom-up ซึ่งเป็นการหาคำตอบของ state ที่อยู่ด้านล่างก่อน (ในกราฟของ state) โดยจะเริ่มจาก base case ที่รู้คำตอบอยู่แล้ว แล้วจะค่อย ๆ สร้างของ state ที่ใหญ่ขึ้นไปเรื่อย ๆ

โค้ดของ Fibonacci ที่ implement แบบ Bottom-up จะเป็นดังนี้

```cpp
int fibonacci(int n) {
    int F[n+1];
    F[0] = F[1] = 1;
    for (int i = 2; i <= n; i++)
        F[i] = F[i-1] + F[i-2];
    return F[n];
}
```

จะเห็นได้ชัดว่าอัลกอริทึมนี้ทำงานใน `O(n)` นอกจากนี้ยังทำงานได้ดีกว่าแบบ top-down เพราะไม่ต้องลำบากกับการเรียกฟังก์ชันแบบ recursive

ถึงอย่างไรก็ตาม การ implement แบบ bottom-up ไม่ได้ดีเสมอไป เพราะโจทย์บางข้อ เราอาจจะหาลำดับการคำนวณตาราง DP ได้ยาก หากใช้แบบ top-down แล้วปล่อยให้ระบบจัดการจนไปถึง base case เองจะสะดวกกว่า นอกจากนี้ โจทย์บางข้อเราไม่จำเป็นต้องคำนวณทุก state ที่เรานิยามไว้ ดังนั้นการ implement แบบ top-down ซึ่งจะเรียกเฉพาะ state ที่จำเป็นต้องใช้อาจจะทำงานได้เร็วกว่า ในการแข่งขัน ควรเลือกใช้วิธีที่เหมาะสมกับโจทย์

### 2.4.3 Steps to solve Dynamic Programming problems

เราจะมาดูขั้นตอนในการแก้โจทย์ DP โดยจะใช้ปัญหา Coin Change เป็นตัวอย่าง

> กำหนดจำนวนเต็ม `n` แทนจำนวนประเภทของเหรียญ และ `k` แทนมูลค่าเงินที่ต้องการ มีลำดับ `C` โดยที่ `C[i]` แทนค่าของเหรียญประเภทที่ `i` - สมมุติให้เหรียญแต่ละประเภทมีจำนวนไม่จำกัด จงหาว่าจะต้องใช้เหรียญน้อยสุดกี่เหรียญจึงจะได้เงินรวมเท่ากับ `k` พอดี

สิ่งแรกที่เราต้องทำเมื่อเราคิดว่าโจทย์สามารถแก้ได้โดยใช้ Dynamic Programming คือสร้างสมการ recursive กำกับคำตอบ ถ้าเราสามารถสร้างสมการ recursive นี้ได้ เราก็สามารถใช้ Top-down หรือ Bottom-up เพื่อทำให้สามารถคำนวณได้รวดเร็ว

การสร้างสมการขึ้นมาเป็นสิ่งที่ต้องอาศัยการฝึกฝนอย่างสูง โดยเฉพาะข้อที่ยาก ๆ และต้องใช้สมการแปลก ๆ 
อย่างไรก็ตาม มันจะง่ายขึ้นถ้าเราคิดตามสามขั้นตอนนี้

1) หาว่าเราควรจะกำหนด state อะไร และ state นั้นบ่งบอกถึงอะไร
2) หาว่า state นั้นจะสามารถสร้างคำตอบจาก state ใดได้บ้าง
3) หาว่าเราจะคำนวณคำตอบของ state นั้นจาก state อื่นอย่างไร

เราจะมาดูว่าเราจะสามขั้นตอนนี้ในการแก้ปัญหา coin change ได้อย่างไร

สำหรับโจทย์ Coin Change การกำหนด state สามารถทำได้โดยสังเกตว่าโจทย์กำหนดอะไรให้บ้าง หรือกำหนดให้หาอะไรบ้าง ในที่นี้ พบว่ามี
- จำนวนประเภทของเหรียญ
- มูลค่าเงินที่ต้องการ
- มูลค่าของประเภทเหรียญแต่ละเหรียญ
- จำนวนเหรียญที่น้อยสุดที่ต้องใช้ (สิ่งที่โจทย์ให้หา)

หากลองกำหนดให้ state ขึ้นอยู่กับจำนวนของเหรียญที่ต้องใช้ ก็อาจจะต้องสร้าง array `dp[i]` มาโดยที่ `i` แทนจำนวนเหรียญที่ใช้ หากลองกำหนดแบบนี้แล้ว เราต้องหาว่า `dp[i]` จะเก็บค่าอะไร ให้ลองพิจารณาไปตามลำดับ
- อาจจะเก็บเป็นผลรวมน้อยสุดที่เป็นไปได้? ก็ไม่เกี่ยวข้องอะไรกับโจทย์ เพราะโจทย์กำหนดผลรวมให้ แต่ให้เราหาจำนวนเหรียญน้อยสุด
- ผลรวมทั้งหมดที่เป็นไปได้? ก็อาจจะยุ่งยากเกินไป

สังเกตว่าการกำหนด state แบบนี้ไม่เหมาะสมมากนัก หากลองกำหนดให้ state ขึ้นอยู่กับมูลค่าของเงินที่ต้องการแทน เราก็สามารถกำหนดให้ `dp[i]` เท่ากับ จำนวนเหรียญที่น้อยที่สุดที่ต้องใช้เพื่อทำให้ได้มูลค่ารวม `i` บาท สังเกตว่่าการกำหนดแบบนี้จะตรงกับสิ่งที่โจทย์ต้องการให้หาพอดี หากเราต้องการเงิน `k` บาทก็สามารถตอบจาก `dp[k]` ได้เลย

สังเกตว่าถ้าเราต้องการเงิน `x` บาท เราอาจจะเลือกใช้เหรียญใดเหรียญหนึ่งก็ได้ เช่น หากเลือกใช้เหรียญ `C[i]` นั่นแปลว่า เรามี 1 เหรียญที่มีมูลค่า `C[i]` บาท และเงินอีก `x-C[i]` บาทที่ต้องพิจารณาหาว่าจะใช้เหรียญใด สังเกตว่าในส่วน `x-C[i]` นั้นเป็นปัญหาย่อยลักษณะเดียวกัน เราสามารถใช้ฟังก์ชัน recursive เพื่อคำนวณว่ามูลค่า `x-C[i]` ต้องใช้เหรียญน้อยสุดเท่าใด เนื่องจากว่าเราต้องการทอนเงิน `x` บาทโดยใช้จำนวนเหรียญน้อยที่สุดที่เป็นไปได้ เราต้องทดลองค่า `i` ตั้งแต่ `1` ถึง `n` เพื่อหาจำนวนเหรียญที่น้อยที่สุด

ดังนั้น สมการเวียนเกิดของ `dp` ของโจทย์ข้อนี้คือ

```
dp[0] = 0 // เงิน 0 บาท ไม่จำเป็นต้องใช้เหรียญ
dp[x] = min(dp[x-C[i]] + 1, 1 <= i <= n and C[i] <= x)
// มีเงิน x บาท หากสร้างจากการใช้เหรียญ C[i] ต้องพิจารณาแก้ปัญหากรณีที่มีเงิน x-C[i] บาทอีก แล้วมารวมกับเหรียญ C[i] 1 เหรยีญ ดังนั้น จะได้คำตอบรวมเป็น dp[x-C[i]] + 1
```

โดยที่ `x` คือราคาของใน state นั้นๆ และคำตอบสุดท้ายคือ `dp[k]`

ถ้าเราเขียน Top-down ก็จะได้โค้ดดังนี้

```cpp
int n, C[N], dp[N];
bool visited[N];

int coin_change(int x) {
    if (x == 0)
        return 0;
    if (visited[x])
        return dp[x];
    visited[x] = true;
    dp[x] = INF;
    for (int i = 1; i <= n; i++) {
        if (C[i] <= x)
            dp[x] = min(solve(x - C[i]) + 1, dp[x]);
    }
    return dp[x];
}
// answer: coin_change(k)
```

แต่ถ้าเราเขียนแบบ Bottom-up ก็จะเป็นแบบนี้

```cpp
int n, C[N], dp[N];
int coin_change(int k) {
    fill(dp, dp+N, INF);
    dp[0] = 0;
    for (int x = 1; x <= k; x++) {
        for (int i = 1; i <= n; i++) {
            if (C[i] <= x)
                dp[x] = min(dp[x - C[i]] + 1, dp[x]);
        }
    }
    return dp[k];
}
```

สังเกตว่า แต่ละ state เราต้องลูปค่า `i` เพื่อหาจำนวนเหรียญที่น้อยที่สุด ซึ่งมีค่า `i` ที่เป็นไปได้ `O(n)` แบบ เนื่องจากมีทั้งหมด `O(k)` state รวมแล้วจะใช้เวลา `O(nk)`

นอกจากนี้ปัญหา Coin Change อาจจะเปลี่ยนคำถาม แทนที่จะให้หาจำนวนเงินน้อยสุด อาจจะถามจำนวนลำดับวิธีการเลือกเหรียญให้มีมูลค่ารวม `k` บาทก็ได้ เช่น หาก `n = 2`, `C = [1, 2]` และ `k = 4` ก็จะได้ 5 รูปแบบดังนี้
- 4 = 1+1+1+1
- 4 = 1+1+2
- 4 = 1+2+1
- 4 = 2+1+1
- 4 = 2+2

ในที่นี้เราสามารถเปลี่ยนสมการเวียนเกิดเป็น

```
dp[0] = 1 // การทอนเงิน 0 บาทสามารถทำได้ 1 แบบคือไม่ใช่เหรียญเลย
dp[x] = sum(dp[x-C[i]], 1 <= i <= n and C[i] <= x)
// การทอนเงิน x บาท สามารถทำได้โดยเลือกเหรียญแรกที่จะใช้ก่อน สมมุติว่าเลือกเหรียญ C[i], แล้วพิจารณานับจำนวนวิธีที่จะทอนเงิน x-C[i] บาท
```

### 2.4.4 Multi-dimensional DP

สังเกตว่าในตัวอย่างก่อนหน้า state `dp` ของเราจะเป็น array 1 มิติ แต่จริง ๆ แล้วหาก state ของเราต้องเก็บข้อมูลมากกว่านั้น เราอาจจะใช้ตาราง 2 มิติขึ้นไปก็ได้

**Maximum Value Monotonic Path**

> กำหนดตารางขนาด `n*m` ให้ โดยช่อง `A[i][j]` จะมีจำนวนเต็ม ให้หาเส้นทางเดินจากตำแหน่ง `(1, 1)` ซึ่งเป็นตำแหน่งมุมบนซ้าย มายังตำแหน่ง `(n, m)` ซึ่งเป็นตำแหน่งมุมล่างขวา โดยอนุญาตให้เดินขวาหรือลงเท่านั้น (ห้ามเดินขึ้นหรือซ้าย) เมื่อเดินเสร็จแล้วจะได้มูลค่าเท่ากับผลรวมของค่า `A[i][j]` ที่เดินผ่านทั้งหมด ถามว่ามูลค่าทางเดินที่มากที่สุดที่เป็นไปได้เท่ากับเท่าใด

สังเกตว่าโจทย์ข้อนี้ ตำแหน่งที่กำหนดให้มาเป็นตำแหน่ง 2 มิติ ดังนั้น เราอาจจะให้ฟังก์ชัน/state ของเรานิยามเป็นตาราง 2 มิติก็ได้ โดยกำหนดให้ `dp[i][j]` เมื่อ `1 <= i <= n` และ `1 <= j <= m` มีค่าเท่ากับ ผลรวมที่มากที่สุดที่เป็นไปได้ เมื่อเดินจากช่อง `(1, 1)` มาถึงช่อง `(i, j)`

สังเกตว่าการที่จะเดินมาถึงช่อง `(i, j)` ได้ เราจำเป็นต้องเดินมาถึงช่อง `(i-1, j)` ก่อนแล้วเดินลง หรือเดินมาถึงช่อง `(i, j-1)` ก่อนแล้วเดินขวา เราจะพิจารณาทั้งสองวิธีที่เป็นไปได้แล้วหาว่าวิธีใดให้ผลรวมมากกว่ากัน จะได้สมการเวียนเกิดดังนี้

```
dp[1][1] = A[1][1] // base case คือกรณีที่จุดเริ่มต้นตรงกับจุดจบ
dp[0][j] = dp[i][0] = -INF // ไม่อนุญาตให้เดินออกขอบ
dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + A[i]
```

คำตอบสุดท้ายจะอยู่ที่ `dp[n][m]`

สังเกตว่ามี state ทั้งหมด `nm` state และแต่ละ state สามารถคำนวณคำตอบได้ใน constant time ดังนั้น รวมแล้วอัลกอริทึมนี้จะใช้เวลา `O(nm)`

นอกจากนี้ยังมีรูปแบบการกำหนด state อีกหลายแบบมาก ตั้งแต่หัวข้อ 2.4.5 เป็นต้นไป เราจะกล่าวถึงวิธีการกำหนด state หลาย ๆ แบบที่พบได้บ่อย ควรฝึกฝนไว้ก่อนเข้าแข่งขันจริง

### 2.4.5 Prefix/Suffix Dynamic Programming

Prefix/Suffix DP เป็นการกำหนด state ในลักษณะที่สนใจเฉพาะส่วนต้นหรือส่วนปลายของปัญหาเท่านั้น เช่น ปัญหา Maximium Independent Set (MIS)

> กำหนดลำดับ `A[1..n]` ให้ ให้หาลำดับย่อย (subsequence) ที่มีผลรวมของสมาชิกมากที่สุด โดยสมาชิกแต่ละตัวของลำดับย่อยจะต้องไม่มีตำแหน่งติดกัน
>
> ตัวอย่าง กำหนดลำดับ `A` เป็น `3, 1, 4, 1, 2, 5` เราจะได้คำตอบเป็น `3, 4, 5` เพราะลำดับนี้มีผลรวมมากที่สุดคือ `3+4+5 = 12` และเลข `3`, `4`, `5` ไม่ได้อยู่ตำแหน่งติดกันในลำดับเดิม

เราสามารถนิยาม state ที่สนใจเฉพาะคำตอบของปัญหาส่วนต้น (prefix) เท่านั้นได้ กล่าวคือ กำหนดให้ `dp[i]` มีค่าเท่ากับ คำตอบที่มากที่สุดที่เป็นไปได้ หากสนใจเฉพาะส่วนลำดับ `A[1..i]` (ส่วน `A[i+1]` เป็นต้นไป ไม่พิจารณาในคำตอบ)

ในการคำนวณค่าของ `dp[i]` เราจะสนใจค่า ณ ตำแหน่ง `i` เป็นหลัก (นั่นคือ `A[i]`) แล้วตัดสินใจเลือกว่า จะรวม `A[i]` เข้าในคำตอบหรือไม่ หรือไม่รวม
- ถ้าเลือกรวม `A[i]` เข้าในคำตอบ เราจะไม่สามารถเลือก `A[i-1]` ได้ เพราะจะอยู่ในตำแหน่งติดกัน ดังนั้น จะได้คำตอบเท่ากับ `dp[i-2] + A[i]` (อย่าลืมว่า `dp[i-2]` คือคำตอบของปัญหาย่อย)
- ถ้าเลือก**ไม่**รวม `A[i]` เข้าในคำตอบ ก็เพียงแค่พิจารณาปัญหาที่เหลืออยู่ หลังตัดตัวที่ `i` ออกมาแล้ว นั่นคือ เราจะได้คำตอบเท่ากับ `dp[i-1]`

เนื่องจากเราต้องการคำตอบที่มากที่สุดที่เป็นไปได้ ดังนั้น `dp[i] = max(dp[i-2]+A[i], dp[i-1])` (อย่าลืมกำหนด base case - ในที่นี้อาจจะกำหนดให้ `dp[-1] = dp[0] = 0` เป็นต้น)

สังเกตว่าแนวทางการกำหนด state ดังกล่าวสนใจเฉพาะส่วนหน้าของปัญหา แต่ความจริงแล้วเราจะเปลี่ยนมาสนใจส่วนหลัง (suffix) ก็ได้ กล่าวคือ กำหนดให้ `dp[i]` เท่ากับคำตอบที่มากที่สุดที่เป็นไปได้ เมื่อพิจารณาลำดับ `A[i..n]` จะทำให้ได้ recurrence เป็น `dp[i] = max(A[i]+dp[i+2], dp[i+1])` และ base case เป็น `dp[n+1] = dp[n+2] = 0`

### 2.4.6 LIS-style Dynamic Programming

ปัญหา Longest Increasing Subsequence (LIS) เป็นอีกปัญหาคลาสสิกที่พบได้บ่อย โจทย์ปัญหาเป็นดังนี้

> กำหนดลำดับ `A[1..n]` ให้ ให้หาลำดับย่อยที่มีความยาวมากที่สุด โดยสมาชิกในลำดับย่อยตัวที่ `i` จะต้องมีค่าน้อยกว่าสมาชิกตัวที่ `i+1` (กล่าวคือ เรียงจากน้อยไปมาก และไม่มีตัวเลขที่เท่ากัน)
>
> ตัวอย่าง ลำดับ `1, 2, 6, 3, 5, 7, 4, 8` มีลำดับย่อยที่ยาวที่สุดที่เป็นไปได้คือ `1, 2, 3, 5, 7, 8` ซึ่งมีความยาวเท่ากับ 6

หากเราพยายามนิยาม state dp คล้าย ๆ ปัญหา Maximum Independent Set กล่าวคือ `dp[i]` เท่ากับ ความยาวสูงสุดของลำดับย่อย เมื่อพิจารณาเฉพาะลำดับ `A[1..i]` จะพบว่าเราไม่สามารถหา recurrence ได้ เพราะตัว state ไม่ได้ให้ข้อมูลเกี่ยวกับตัวเลขในลำดับเลย ทำให้เราไม่ทราบว่าเราจะบังคับเงื่อนไข "น้อยไปมาก" ได้อย่างไร

หากเราเปลี่ยนนิยามเป็น `dp[i]` เท่ากับ ความยาวสูงสุดของลำดับย่อย**ที่มาจบที่ตำแหน่ง `i` พอดี** (ให้ `dp[0] = 0` เพราะไม่มีทางที่ลำดับย่อยจะจบก่อนหน้าตัวแรกได้) จะพบว่า เราสามารถหา recurrence ได้อย่างง่ายดาย

เนื่องจากนิยามของเราบังคับว่าต้องจบที่ตำแหน่ง `i` ยังไงเราต้องมี `A[i]` เป็นตัวสุดท้ายของลำดับย่อยแน่ ๆ สิ่งที่เราต้องเลือกคือเลือกว่าตัวก่อนหน้าในลำดับมีอะไรบ้าง ในที่นี้เราอาจจะแก้ปัญหา `dp` ส่วนก่อนหน้าไว้ก่อน แล้วเลือกว่าจะนำลำดับที่จบที่ตำแหน่งก่อนหน้าตำแหน่งใด มาต่อกับตำแหน่ง `i`

สมมุติว่าจะเลือกลำดับที่จบที่ตำแหน่ง `j` อยู่ (`0 <= j < i`) เราจะเลือกได้ก็ต่อเมื่อ `A[j] < A[i]` เท่านั้น หากเลือกได้ เราจะได้ลำดับที่มีความยาวเป็น `dp[j]+1` (คือ ลำดับที่มาจบที่ตำแหน่ง `j` แล้วเพิ่มตัวที่ `i` เข้าไปต่อท้าย)

ดังนั้น เราสามารถเขียนสมการเวียนเกิดได้ ดังนี้

```
dp[0] = 0
dp[i] = max(dp[j]+1, 0 <= j < i and A[j] < A[i])
```

เนื่องจากปัญหา LIS ต้องการลำดับที่จบ ณ ตำแหน่งใดก็ได้ ดังนั้น คำตอบของเราจะเท่ากับ `max(dp[i], 1 <= i <= n)`

นอกจากปัญหา Longest Increasing Subsequence แล้ว ยังมีปัญหาอื่นที่สามารถใช้แนวคิดคล้าย ๆ กันได้อีกด้วย เช่น ปัญหา Maximum Sum Subarray

>กำหนดลำดับ `A[1..n]` (อาจมีตัวเลขติดลบ) ให้เลือกค่า `i`, `j` โดยที่ `1 <= i <= j <= n` ที่ทำให้ `sum(A[i..j])` มากที่สุดที่เป็นไปได้ กล่าวคือ ให้เลือกช่วงย่อยของลำดับที่มีผลรวมมากที่สุด

เราอาจจะนิยามให้ `dp[i]` เท่ากับ ผลรวมที่มากที่สุดที่เป็นไปได้ เมื่อพิจารณาเฉพาะช่วงย่อยที่มาจบที่ตำแหน่ง `i` พอดี สังเกตว่าเราต้องมี `A[i]` อยู่ในช่วงอยู่แล้ว ตามนิยาม สิ่งที่เราเลือกได้คือ เราจะนำมาต่อกับช่วงก่อนหน้า (`dp[i-1]`) หรือไม่ เราต้องการวิธีที่ทำให้ได้ผลรวมมากที่สุด ดังนั้น `dp[i] = max(A[i], A[i]+dp[i-1])` (base case อาจจะกำหนดให้ `dp[1] = A[1]`)

### 2.4.7 Substring Dynamic Programming

โจทย์บางข้อ เราไม่สามารถสนใจเพียงแค่ส่วน prefix/suffix แต่ต้องสนใจทุก substring ที่เป็นไปได้ ยกตัวอย่างโจทย์ดังนี้

> มีลำดับ `A[1..n]` เราสามารถเลือกแบ่งลำดับนี้ออกเป็นสองส่วน ซ้าย-ขวา ได้ เช่น แบ่งเป็นลำดับ `A[1..i]` และ `A[(i+1)..n]` เป็นต้น เมื่อแบ่งเสร็จแล้ว สามารถแบ่งต่อไปได้อีกจนกว่าจะเหลือลำดับความยาว 1 ทั้งหมด การแบ่งแต่ละครั้งจะใช้เวลาเท่ากับผลรวมของสมาชิกในลำดับทั้งหมด จงหาว่า หากต้องการจะแบ่ง `A[1..n]` เป็นลำดับความยาว 1 ทั้งหมด จะต้องใช้เวลาอย่างน้อยสุดเท่าใด

เราอาจจะนิยามให้ `dp[i][j]` เท่ากับ เวลาที่น้อยที่สุดที่เป็นไปได้ หากต้องการจะแบ่งลำดับ `A[i..j]` ให้กลายเป็นลำดับความยาว 1 ทั้งหมด คำตอบสุดท้ายของเราคือ `dp[1][n]` (เพราะเราต้องการแบ่งลำดับทั้งหมด)

สังเกตว่า ในการหาคำตอบ `dp[i][j]` เราสามารถเลือกได้ว่าจะแบ่ง ณ ตำแหน่งใด สมมุติเลือกแบ่ง ณ ตำแหน่ง `k` (แบ่งเป็นลำดับ `A[i..k]` และ `A[(k+1)..j]`) การแบ่งจะใช้เวลาเท่ากับ `dp[i][k] + dp[k+1][j] + sum(A[i..j])`

เราต้องเลือกตำแหน่งที่แบ่งแล้วใช้เวลาน้อยสุด ดังนั้น จะเขียน recurrence relation ได้ดังนี้

```
dp[i][i] = 0 // ลำดับความยาว 1 ไม่จำเป็นต้องแบ่งอีก
dp[i][j] = min(dp[i][k]+dp[k+1][j] + sum(A[i..j]), i <= k < j)
```

อนึ่ง สังเกตว่าส่วนที่เป็นการหาผลรวม สามารถหาได้อย่างรวดเร็วหากสร้าง prefix sum array ไว้ก่อน

### 2.4.8 Partitioning Problem

อีกประเภทหนึ่งที่พบได้บ่อย จะเป็นโจทย์แนวแบ่งช่วงลำดับ ดังนี้

> กำหนดลำดับ `A[1..n]` ให้แบ่งออกเป็น `p` ช่วงที่ติดกัน โดยให้ผลรวมของค่า `F` แต่ละช่วงน้อยที่สุดที่เป็นไปได้ นิยามให้ `F(i, j)` (ค่า `F` ของช่วง `A[i..j]`) มีค่าเท่ากับ `max(A[i..j]) - min(A[i..j])`

ในที่นี้ นิยามของฟังก์ชัน `F` อาจจะต่างกันแล้วแต่โจทย์ โจทย์บางข้ออาจจะกำหนดเงื่อนไขเพิ่มเติม เช่น เงื่อนไขความยาวช่วง ว่าช่วงต้องมีจำนวนสมาชิกอยู่ระหว่าง `x` ถึง `y` เป็นต้น

สำหรับโจทย์ข้อนี้ เราสามารถนิยาม state `dp[i][j]` เท่ากับ ผลรวมที่น้อยที่สุดที่เป็นไปได้ เมื่อแบ่งลำดับ `A[1..j]` ออกเป็น `i` ช่วงเป๊ะ ๆ (สังเกตว่าตัวที่ `j` จะอยู่ในช่วงสุดท้าย ก็คือช่วงที่ `i`)

การหาค่า `dp[i][j]` สามารถทำได้โดยทดลองเลือกตำแหน่งเริ่มต้นของช่วงสุดท้าย (ช่วงที่ `i`) ส่วนตัวที่เหลือที่ไม่ได้อยู่ในช่วง จะถูกแบ่งต่อไปเรื่อย ๆ จนกว่าจะครบ ในที่นี้ หากเลือกแบ่งช่วงสุดท้ายเป็น `A[k..j]` ก็จะได้คำตอบเท่ากับ `dp[i-1][k-1] + F(k, j)` (สังเกตว่า `k-1` ตัวที่เหลือ จะต้องถูกแบ่งออกไปอีก `i-1` ช่วง)

จะได้สมการเวียนเกิดดังนี้
```
dp[0][0] = 0 // ไม่เหลืออะไรให้แบ่งแล้ว ดังนั้นค่า F รวมจะเท่ากับ 0
dp[i][0] = INF // ไม่เหลือตัวให้แบ่งแล้ว แต่เราจำเป็นต้องแบ่งอีก i ช่วง (อย่าลืมว่าเราต้องการแบ่งเป็น i ช่วงเป๊ะ ๆ)
dp[0][j] = INF // มีตัวที่ต้องนำมาพิจารณาแบ่งอยู่ แต่ไม่สามารถแบ่งได้ เพราะเรามีสิทธิ์แบ่งได้อีกแค่ 0 ช่วง
dp[i][j] = min(dp[i-1][k-1] + F(k, j), 1 <= k <= j)
```

สุดท้ายแล้ว คำตอบของเราจะอยู่ที่ `dp[p][n]`

สำหรับโจทย์ข้ออื่น อาจจะดัดแปลง base case หรือเงื่อนไขค่า `k` ได้ตามความเหมาะสม

### 2.4.9 DP on Directed Acyclic Graph (DAG)

โจทย์ DP ไม่จำเป็นต้องทำบนลำดับเสมอไป แต่อาจจะทำบนกราฟได้ ส่วนใหญ่กราฟที่กำหนดให้จะเป็นกราฟแบบระบุทิศทางที่ไม่มีวัฐจักร ยกตัวอย่างโจทย์ดังนี้

> กำหนด Directed Acyclic Graph ขนาด `n` node `m` edge ให้ จงหาเส้นทางสั้นที่สุดจาก node `1` ไปยัง node `n`

เนื่องจากกราฟมีลักษณะพิเศษ เราไม่จำเป็นต้องใช้ Single-source Shortest Path Algorithm เช่น Dijkstra's Algortihm ก็ได้ แต่ใช้ Dynamic Programming แทน โดยนิยาม state `dp[u]` คือ เส้นทางสั้นสุดจาก node `u` ไปยัง node `n`

เมื่อคำนวณค่า `dp[u]` เราจะพิจารณา node `v` ทุก node ซึ่งอยู่ใน adjacency list ของ `u` แล้วหาว่า เราควรเดินทางไปเส้นทางใด หากกำหนดให้ edge `(u, v)` มีน้ำหนัก `w` จะได้ความยาวของเส้นทางเท่ากับ `dp[v]+w`

เนื่องจากเราต้องการเส้นทางสั้นสุด ก็จะได้ว่า `dp[u] = min(dp[v]+w, for all v with edge (u, v, w))` ดังนั้น คำตอบสุดท้ายของเราจะอยู่ใน `dp[1]`

เราสามารถ implement สูตรดังกล่าวแบบ top-down ได้อย่างง่ายดาย เพราะไม่จำเป็นต้องสนใจเรื่องลำดับของ node ที่จะพิจารณาแก้ `dp` แต่หากต้องการทำแบบ bottom-up เราจำเป็นต้องทำ topological sort ก่อน แล้วทำไล่ย้อนหลังขึ้นมา (ในที่นี้ จะไล่ย้อนหลังจากค่า `dp[n]` ซึ่งเราทราบอยู่แล้ว ขึ้นมาถึง `dp[1]`)

ส่วนใหญ่แล้วโจทย์ DP ที่ทำบนกราฟ เราสามารถทำแบบ top-down ได้โดยไม่ต้องห่วงเรื่อง constant factor มากนัก

### 2.4.10 Bitmask Dynamic Programming

โจทย์บางข้อ เราอาจจะจำเป็นต้องเก็บข้อมูลการตัดสินใจครั้งที่ผ่านมาเป็นจำนวนเต็ม แต่บางข้อเก็บเพียงจำนวนเต็มเพียงตัวเดียวไม่พอ เราอาจจะต้องเก็บสถานะ `true/false` หลายตัว วิธีที่ง่ายที่สุดคือการใช้จำนวนเต็มโดยให้แต่ละ bit ของจำนวนเก็บสถานะแต่ละสถานะ แล้วใช้ bitwise operator ในการดำเนินการจัดการกับตัวเลขดังกล่าว

ในที่นี้ขอกล่าวถึงโจทย์ข้อ Bond ซึ่งเป็นปัญหาเดียวกันที่ยกตัวอย่างไว้ในหัวข้อ 2.1.2 Recursive Brute Force - แนะนำให้ย้อนกลับไปอ่านโค้ด Brute Force ก่อน

**Bond - COCI 2006/2007, Contest #1**

> กำหนดตารางขนาด `n*n` ให้ แต่ละช่องมีจำนวนเต็มกำกับอยู่ แสดงถึงความน่าจะเป็น มีค่าตั้งแต่ 0 ถึง 100 ให้เลือกตัวเลขในตารางมา `n` ตัว โดยที่ตัวเลขที่เลือกจะต้องไม่มีตัวใดอยู่ในแถวเดียวกันหรือหลักเดียวกัน จงหาว่าจะสามารถเลือกให้ได้ผลคูณของความน่าจะเป็นมากที่สุดเท่าใด (ตอบเป็นทศนิยม 6 หลัก มีค่าตั้งแต่ 0 ถึง 100)

ในการทำ Dynamic Programming เราไม่สามารถเก็บข้อมูลไว้ข้างนอกฟังก์ชันเหมือน Brute Force ได้ (สังเกตว่าในฟังก์ชัน Brute Force เราเก็บ array `used` ไว้เพื่อตรวจสอบ) เพราะข้อมูลดังกล่าวจะถือว่าเป็นส่วนหนึ่งของ state DP ดังนั้นเราจะต้องนำข้อมูลใส่มาในฟังก์ชันด้วย

วิธีหนึ่งที่จะเก็บข้อมูลได้คือ ใช้จำนวนขนาด `n` bit โดยเมื่อ bit ที่ `i` เป็น `0` ก็จะเปรียบเสมือน `used[i] = false` ส่วนเมื่อมีค่าเป็น `1` ก็จะเปรียบเสมือน `used[i] = true` - ในที่นี้จำนวนเต็มขนาด `n` bit ดังกล่าวจะขอเรียกว่า `conf` (configuration)

นอกจากนี้ ฟังก์ชันใน Dynamic Programming จะต้อง return คำตอบ (Brute Force ของเราใช้การเซตคำตอบดีสุดทางด้านนอก) ดังนั้น จะขอนิยามให้ `solve(i, conf)` มีค่าเท่ากับ มูลค่าที่มากที่สุดที่เป็นไปได้ เมื่อต้องเริ่มเลือกตั้งแต่แถวที่ `i` ไปถึงแถวที่ `n` โดยที่ไม่อนุญาตให้เลือกตัวที่ระบุไว้ว่าห้ามใช้ใน `conf` (ห้ามเลือกตัวที่มี bit เป็นเลข 1)

สังเกตว่า ณ ตำแหน่งปัญหา `solve(i, conf)` เราสามารถทดลองเลือกทุก column `j` (`1 <= j <= n`) แล้วพิจารณาเฉพาะคอลัมน์ที่อนุญาตให้เลือกได้ เหมือนกับการ Brute Force ในที่นี้ สามารถตรวจสอบได้จาก `conf&(1<<j)` หากมีค่าเป็น `0` นั่นคือ bit ที่ `j` ยังไม่เคยถูกเซตไว้ สามารถเลือกได้ (หากมีค่าเป็นอย่างอื่น นั่นคือเคยเซต bit ที่ `j` ไว้แล้ว จะเลือกไม่ได้)

หากสามารถเลือกคอลัมน์นั้นได้ จะได้มูลค่าเท่ากับค่าที่เลือก (`A[i][j]`) คูณกับ `solve(i+1, conf|(1<<j))` - สังเกตว่าปัญหาย่อยที่เราเรียก เรานำ `conf` มาทำ operation `OR` (`|`) กับ `(1<<j)` เพื่อกำหนดให้ bit ที่ `j` เป็น `1` นั่นคือ กำหนดว่าไม่สามารถใช้ column ที่ `j` ได้อีกแล้ว

สำหรับ base case จะเป็นกรณีที่ `i = n+1` - เนื่องจากเลือกครบทุกแถวแล้ว ไม่สามารถเลือกอะไรได้อีก เพื่อไม่ให้ base case ส่งผลต่อคำตอบอื่น ๆ เราจะกำหนดให้คำตอบเป็น 1 (1 คูณอะไรก็ได้ตัวนั้น)

จะเขียนสมการเวียนเกิดได้ดังนี้
```
solve(n+1, conf) = 1
solve(i, conf) = max(A[i][j] * solve(i+1, conf|(1<<j)), 1 <= j <= n and conf&(1<<j) = 0)
```

คำตอบสุดท้ายจะอยู่ใน `solve(1, 0)` นั่นคือ การพิจารณาปัญหาเริ่มตั้งแต่แถวที่ 1 เป็นต้นไป โดยตอนแรกอนุญาตให้เลือกคอลัมน์ใดก็ได้

เมื่อมองฟังก์ชันนี้ครั้งแรก อาจจะคิดว่ามี state ที่เป็นไปได้ทั้งหมด `n * (2^n)` state แต่ความจริงแล้วฟังก์ชันนี้จะมีเพียง `2^n` state เท่านั้น เนื่องจากว่าค่า `i` ถูกบังคับโดยรูปแบบที่เลือกใน `conf` อยู่แล้ว - กล่าวคือ ถ้า `conf` มี bit `1` อยู่ `x` bit `i` จะมีค่าเท่ากับ `x+1` (ถ้าเลือกไปแล้ว `x` คอลัมน์ แถวต่อไปที่พิจารณาก็คือแถวที่ `x+1` นั่นเอง)

สรุปคือ ตัวแปร `i` ที่กำหนดไว้ในฟังก์ชัน มีเพื่อความสะดวกเฉย ๆ หากจะตัดทิ้งก็สามารถตัดได้ แต่เราต้องนับจำนวน bit ใน `conf` ด้วยตัวเอง เพื่อความสะดวก หากเขียนฟังก์ชันแบบ top-down ควรมีค่า `i` ไว้ตลอด แต่ในการเก็บ array `dp` จะใช้เพียงมิติเดียวก็ได้ (มิติที่เก็บค่า `conf`)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 21;

int n;
double A[N][N];
double dp[1<<N];
bool visited[1<<N];

double solve(int i, int conf) {
    // base case
    if (i == n+1)
        return 1;
    if (visited[conf])
        return dp[conf];

    // try picking each column
    double mx = 0;
    for (int j = 1; j <= n; ++j) {
        if ((conf&(1<<j)) != 0) // can't pick already-used column
            continue;
        // if can pick, try picking then call recursively
        mx = max(mx, A[i][j] * solve(i+1, conf|(1<<j)));
    }

    // return maximum answer
    visited[conf] = true;
    dp[conf] = mx;
    return mx;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            scanf("%lf", &A[i][j]);
            A[i][j] /= 100.0; // must convert to real number in [0, 1]
        }
    }
    printf("%.6f\n", solve(1, 0)*100.0); // must convert back to range [0, 100]
    return 0;
}
```
