# Table of Contents

**2. Problem Solving Paradigms**
  - 2.1 Brute Force
    - 2.1.1 Iterative Complete Search
    - 2.1.2 Recursive Complete Search
    - 2.1.3 Simulation
  - 2.2 Divide and Conquer
    - 2.2.1 Binary Search
    - 2.2.2 การแปลง Optimization Problem เป็น Decision Problem
  - 2.3 Greedy
  - 2.4 Dynamic Programming

# 2. Problem Solving Paradigms

## 2.1 Brute Force

Brute Force เป็นวิธีการแก้ปัญหาที่ง่ายที่สุด เพราะไม่จำเป็นต้องคิดวิธีที่ดีอะไรมาก เพียงแค่ทดลองทุกคำตอบ/ทุกกรณีที่เป็นไปได้ แล้วตอบคำตอบที่ดีที่สุด (หรือตอบจำนวนวิธีที่เป็นไปได้ หากโจทย์ถามหาจำนวนวิธีในการทำอะไรบางอย่าง) จะหนักที่การ implement ซะมากกว่า

ถึงโจทย์ส่วนใหญ่จะให้คะแนนวิธีนี้น้อย เราควรศึกษาและฝึก implement Brute Force ให้ดี ๆ เพราะหากหาวิธีที่ดีไม่ได้ การทำ Brute Force ก็อาจจะช่วยให้ได้คะแนนได้บางส่วน

### 2.1.1 Iterative Complete Search

โจทย์บางข้อสามารถ Brute Force ได้โดยการทดลองลูปบนคำตอบทั้งหมดที่เป็นไปได้ โดยอาจจะลูปหลายชั้น เช่น

> กำหนดลำดับตัวเลขมาให้ `n` ตัว ให้เลือกตัวเลขสองตัวที่มีค่าต่างกันน้อยที่สุดที่เป็นไปได้

วิธีหนึ่งที่ทำได้ คือลูปสองชั้นเพื่อทดลองเลือกตัวเลขสองตัวทุกแบบที่เป็นไปได้ หาวิธีการเลือกที่ได้ค่าแตกต่างกันน้อยที่สุดแล้วตอบ

> กำหนดจำนวนเต็ม `A` และ `B` ให้ จงหาจำนวนเต็มบวก `x` และ `y` ทุกคู่ที่ตรงตามเงื่อนไข `x+y = A` และ `x*y = B`

ใช้การทดลองลูปสองชั้นเพื่อทดลองค่า `x`, `y` ทั้งหมดที่เป็นไปได้ (ไม่เกิน `A` หรือ `B`) แล้วตรวจสอบเงื่อนไขทั้งสองเงื่อนไข ถ้าตรงเงื่อนไขก็ตอบคู่นั้น วิธีนี้จะใช้เวลา `O(min(A, B)^2)`

สังเกตว่าความจริงแล้วเราไม่จำเป็นต้องลูปค่า `y` ก็ได้ เพราะหากเลือกค่า `x` แล้ว เราสามารถสรุปได้ทันทีว่า `y = A-x` ตามสมการแรก สิ่งที่ต้องทำมีเพียงแค่การตรวจสอบเงื่อนไข `x*y = B` ว่าเป็นจริงหรือไม่ วิธีนี้จะใช้เวลา `O(min(A, B))`

### 2.1.2 Recursive Complete Search

โจทย์บางข้อจำเป็นต้องทดลองวิธีเป็นจำนวนมาก และไม่สามารถใช้ลูปหลายชั้นในการแก้ได้ ดังนั้นจึงต้องเขียน recursive function เพื่อทดลองเลือกทุกวิธีที่เป็นไปได้แทน

**Perket - COCI 2008/2009 Contest #2**

> ต้องการทำอาหาร มีส่วนผสมให้ทั้งหมด `n` ชิ้น (`n <= 10`) โดยส่วนผสมแต่ละชิ้นจะมีค่าความเปรี้ยวและค่าความขม ให้เลือกส่วนผสมมาทำอาหาร (เลือกกี่ชิ้นก็ได้ แต่ต้องอย่างน้อย 1 ชิ้น) เมื่อทำอาหาร จะได้อาหารที่มีค่าความเปรี้ยวเท่ากับผลคูณของค่าความเปรี้ยวของส่วนผสมที่เลือกมา ส่วนค่าความขมจะเท่ากับผลบวกของค่าความขมของส่วนผสมที่เลือกมา ให้หาวิธีเลือกโดยให้ความต่างระหว่างค่าความขมกับค่าความเปรี้ยวน้อยที่สุดเท่าที่เป็นไปได้
>

สังเกตว่าเราต้องการทดลองเลือกทุกสับเซตที่เป็นไปได้ (ยกเว้นเซตว่าง) แล้วหาสับเซตที่มีค่าความต่างน้อยที่สุด วิธีการหนึ่งที่เป็นไปได้คือการเลือกตัดสินใจว่า ชิ้นที่ 1 จะเอาหรือไม่ ชิ้นที่ 2 จะเอาหรือไม่, ..., ชิ้นที่ `n` จะเอาหรือไม่

ในการทดลอง เราสร้าง array ของ `bool` ชื่อ `picked` ขึ้นมา โดยนิยามให้ `picked[i]` เป็น `true` ถ้าเลือกใช้ส่วนผสมชิ้นที่ `i` และเป็น `false` ถ้าไม่เลือกใช้

ต่อมา กำหนดฟังก์ชัน recursive ชื่อ `pick(i)` ซึ่งจะทำหน้าที่กำหนดค่าให้ `picked[i]` เป็น `true`, เรียก `pick(i+1)` เพื่อทำการเลือกส่วนผสมชิ้นถัด ๆ ไปทุกแบบที่เป็นไปได้ เมื่อ return กลับมาแล้วจึงกำหนดค่าให้ `picked[i]` เป็น `false` แล้วเรียก `pick(i+1)` เพื่อทดลองทุกความเป็นไปได้เช่นเดียวกัน

ในกรณีที่เรียก `pick(n+1)` จะถือว่าทดลองเลือกของมาแล้ววิธีหนึ่งตามที่ระบุใน array `picked`, ฟังก์ชันจะทำการคำนวณค่าความต่าง พร้อมเช็คเงื่อนไขเพื่อให้มั่นใจว่าไม่ได้เลือกเซตว่างมา หากค่าความต่างน้อยกว่าค่าความต่างน้อยสุดที่เคยเก็บไว้ ก็ให้จดคำตอบใหม่

ดูโค้ดตัวอย่างด้านล่าง

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20;
const int INF = 1e9;

int n;
int sour[N], bitter[N];
bool picked[N];
int ans = INF;

void pick(int i)
{
    if (i <= n) {
        picked[i] = true;
        pick(i+1);
        picked[i] = false;
        pick(i+1);
    } else { // i == n+1
        int total_sour = 1, total_bitter = 0, count_used = 0;
        for (int j = 1; j <= n; ++j) {
            if (picked[j]) {
                ++count_used;
                total_sour *= sour[j];
                total_bitter += bitter[j];
            }
        }
        if (count_used != 0)
            ans = min(ans, abs(total_sour - total_bitter));
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d%d", &sour[i], &bitter[i]);
    pick(1);
    printf("%d\n", ans);
    
    return 0;
}
```

**N-Queen Problem**

> มีกระดานหมากรุกขนาด `n*n` ให้วาง Queen ทั้งหมด `n` ตัวโดยที่ Queen แต่ละตัวต้องไม่ attack Queen ตัวอื่น (จะ attack ก็ต่อเมื่ออยู่ในแถว/คอลัมน์/แนวทแยงเดียวกันเท่านั้น)

แต่ละแถว จะต้องเลือกตำแหน่งให้ queen อยู่ ณ คอลัมน์ใดคอลัมน์หนึ่ง โดยเมื่อเลือกเสร็จแล้ว ต้องตรวจสอบว่าแต่ละคอลัมน์ถูกเลือกเพียงครั้งเดียวเท่านั้น นอกจากนี้ queen แต่ละตัวต้องไม่อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่น ๆ ด้วย หากไม่ขัดเงื่อนไขก็สามารถตอบวิธีการวางดังกล่าวได้

สังเกตว่า เราไม่จำเป็นต้องรอจนจบแล้วค่อยเช็คเงื่อนไขก็ได้ แต่สามารถเช็คระหว่างเลือกได้เลย หากพบว่าเลือกแล้วขัดเงื่อนไขใดเงื่อนไขหนึ่ง ก็ให้ข้ามตัวเลือกนั้น แล้วทดลองเลือกตำแหน่งถัดไปได้เลย วิธีดังกล่าวเรียกว่า Recursive Backtracking

### 2.1.3 Simulation

โจทย์บางข้อกำหนดสถานการณ์มาให้ แล้วคุณต้องตอบคำถามตามที่โจทย์กำหนด วิธีที่ง่ายที่สุดวิธีหนึ่งคือการ implement โค้ดเพื่อจำลองสถานการณ์แล้วตอบคำถาม

> กำหนดลำดับจำนวนเต็ม `1` ถึง `n` มาให้ ให้ทำการ sort array ดังกล่าวด้วย bubble sort - มีคำถามมาให้ `q` คำถาม แต่ละคำถามถามว่า ใน bubble sort pass ที่ `k` ตัวเลข `x` อยู่ที่ตำแหน่งใด

เราอาจจะสร้าง array 2 มิติขึ้นมาเพื่อเก็บสภาพของ array หลังการ bubble sort แต่ละรอบ แล้วตอบคำถามแต่ละคำถาม

## 2.2 Divide and Conquer

แนวคิดหลัก ๆ ของ Divide and Conquer คือ แบ่งปัญหาออกเป็นหลายส่วนที่เท่า ๆ กัน ใช้อัลกอริทึมเดิมแก้ปัญหาย่อย ๆ ซ้ำแบบ recursive แล้วหาวิธีรวมคำตอบเข้าด้วยกัน เป็นคำตอบของปัญหาใหญ่ (โดยส่วนใหญ่ จะแบ่งออกเป็น 2 ส่วนเท่า ๆ กัน)

ยกตัวอย่างอัลกอริทึม Divide and Conquer เช่น Merge Sort ที่ใช้การ sort array ครึ่งแรกกับครึ่งหลังแยกกัน แล้วค่อยนำ array ทั้งสองมารวมกัน เนื่องจากว่ามีการแบ่งครึ่งลงไปทั้งหมด `O(log n)` ชั้น แต่ละชั้นจะต้องจัดการกับสมาชิกของ array เพื่อทำการรวม array - รวมทั้งหมด `O(n)` ตัว ทำให้เวลาการทำงานของ merge sort เป็น `O(n log n)`

ในการแข่งขัน TOI ปกติจะไม่ค่อยเจอโจทย์ Divide and Conquer ท่าแปลก ๆ มาก ยกเว้นการ Binary Search บนปัญหา Optimization Problem ที่ถูกแปลงเป็น Decision Problem ซึ่งพบได้บ่อยมาก ควรศึกษาไว้

### 2.2.1 Binary Search

> กำหนดลำดับจำนวนให้ทั้งหมด `n` ตัว มีคำถามให้ `q` คำถาม แต่ละคำถาม ให้หาว่ามีเลข `x` อยู่ในลำดับหรือไม่

เราสามารถ sort array ดังกล่าวเรียงจากน้อยไปมากก่อน แล้วสำหรับแต่ละคำถาม เราจะมีวิธีดังนี้
- ตอนแรก ดูตำแหน่งกลางของ array ก่อน หากตัวเลขตรงกับตัวที่ต้องการหา ก็จบการทำงาน ตอบได้ว่ามีตัวเลขดังกล่าว
- หากไม่ใช่ ให้ดูว่าตัวเลขที่เราต้องการมีค่าน้อยกว่าหรือมากกว่าตัวเลขตำแหน่งตรงกลาง
- หากตัวเลขที่เราต้องการมีค่าน้อยกว่า แสดงว่าอาจจะอยู่ทางซ้าย เราจะมาค้นหาในช่วงครึ่งซ้ายแทน แต่หากมากกว่า ให้ค้นหาในช่วงครึ่งขวา
- การค้นหาแต่ละช่วง จะใช้ดูค่าตรงกลาง แล้วเลือกครึ่งที่สมควรค้นหาเรื่อย ๆ เช่นเดียวกัน

สังเกตว่าแต่ละครั้ง array ของเราจะถูกตัดออกไปทีละครึ่ง ดังนั้น รวมแล้วจะใช้เวลาไม่เกิน `O(log n)` ในการตอบคำถามแต่ละครั้ง

### 2.2.2 การแปลง Optimization Problem เป็น Decision Problem

ปัญหาที่ต้องการให้หาค่าน้อยสุด/มากสุดบางอย่าง สามารถแปลงมาเป็นปัญหาการตัดสินใจ (ที่ต้องตอบ Yes/No) เพื่อที่จะทำให้หาคำตอบโดยการ binary search ได้ ทำให้แก้ปัญหาได้ง่ายขึ้น ยกตัวอย่างดังนี้

> มีลำดับจำนวนเต็มบวกอยู่ `n` ตัว ต้องการแบ่งเป็นช่วง ๆ โดยจะมีค่า `x` กำหนดไว้ แต่ละช่วงจะต้องมีผลรวมของสมาชิกไม่เกิน `x` ถามว่า หากเราต้องการแบ่งออกเป็นช่วงไม่เกิน `k` ช่วง เราสามารถกำหนดค่า `x` ให้น้อยสุดได้เท่าไหร่

ยกตัวอย่าง หากมีลำดับ `3, 5, 1, 2, 4` และ `k = 2` หากเรากำหนดให้ `x = 7` จะพบว่า การแบ่งโดยให้แต่ละช่วงมีผลรวมไม่เกิน `x = 7` จะต้องใช้อย่างน้อย 3 ช่วง เช่น `[3], [5], [1, 2, 4]` - ค่า `x` นี้ใช้ไม่ได้ เพราะเราต้องการแบ่งเป็นช่วงไม่เกิน `k = 2` ช่วง

หากเรากำหนดให้ `x = 8` พบว่าเราสามารถแบ่งเป็น `[3, 5], [1, 2, 4]` ซึ่งใช้เพียง `k = 2` ช่วงเท่านั้น ไม่ขัดกับเงื่อนไขโจทย์

สังเกตว่า หากเราเปลี่ยนปัญหาจาก "หาค่า `x` ที่น้อยสุดที่เป็นไปได้" เป็น "ตรวจสอบว่า ถ้าแบ่งให้แต่ละช่วงมีผลรวมไม่เกิน `x` จะแบ่งให้มีไม่เกิน `k` ช่วงได้หรือไม่" เราจะตอบปัญหาแบบหลังได้ง่ายขึ้น

การตรวจสอบว่าทำได้หรือไม่ สามารถทำได้แบบ greedy - เริ่มต้นมา ให้ช่วงแรกประกอบด้วยจำนวนตัวแรกเพียงตัวเดียว พยายามเพิ่มตัวถัดไปเรื่อย ๆ ตราบใดที่ผลรวมยังไม่เกิน `x` - ถ้าเกินแล้ว ให้เริ่มต้นช่วงใหม่ - ทำไปเรื่อย ๆ จนครบทุกตัว แล้วตรวจสอบว่าจำนวนช่วงเกิน `k` หรือไม่

เมื่อเราสามารถตรวจสอบคำตอบได้อย่างง่ายดาย การที่จะแก้ปัญหาดั้งเดิมได้นั้น ก็เพียงแค่ binary search บนค่า `x` โดยมีเงื่อนไขดังนี้
- เริ่มต้นมา พิจารณาช่วงค่า `x` ที่เป็นไปได้ตั้งแต่ `1` ถึง `INF` (เมื่อ `INF` คือ bound ผลรวมที่มากที่สุดที่เป็นไปได้ของ array ทั้ง array)
- ทดลองค่า `x` ตรงกลางช่วง หากตรวจสอบแล้วสามารถทำให้เงื่อนไขเป็นจริงได้ สังเกตว่าถ้าเราเพิ่มค่า `x` ยังไงเงื่อนไขก็ยังเป็นจริงอยู่ แต่เราต้องการค่า `x` น้อยสุด ดังนั้น เราจะพิจารณาเฉพาะช่วงคำตอบ `x` ตั้งแต่ 1 ถึงค่าดังกล่าว (เผื่อทำให้ `x` น้อยกว่านี้ได้อีก)
- หากทดลองแล้วพบว่าเงื่อนไขเป็นเท็จ นั่นแปลว่าเราจำเป็นต้องเพิ่มค่า `x` เพราะฉะนั้น เราจะพิจารณาค่า `x` ที่เป็นไปได้ ตั้งแต่ ค่าดังกล่าวบวก 1 ถึง `INF`
- เราจะแบ่งครึ่งช่วงไปเรื่อย ๆ จนกว่าจะเหลือเพียงค่าเดียว ได้เป็นคำตอบของคำถามดังกล่าว

```cpp
#include <bits/stdc++.h> // <- include everything
using namespace std;

const int N = 100010;
const long long INF = 1e18;

int n, k;
long long val[N];

bool check(long long limit)
{
    int cnt = 1;
    long long sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (val[i] > limit)
            return false;
        // เริ่มต้นช่วงใหม่ ถ้าเพิ่มตัวใหม่เข้าไปแล้วทำให้ผลรวมเกิน
        if (sum + val[i] > limit) {
            ++cnt;
            sum = 0;
        }
        sum += val[i];
    }
    return cnt <= k;
}

int main()
{
    scanf("%d%d", &k, &n);
    for (int i = 1; i <= n; ++i)
        scanf("%lld", &val[i]);
    
    long long lo = 1;
    long long hi = INF;
    while (lo < hi) {
        long long mid = (lo+hi)/2;
        if (check(mid))
            hi = mid;
        else
            lo = mid+1;
    }
    printf("%lld\n", lo);
    
    return 0;
}
```

## 2.3 Greedy

Greedy Algorithm คือขั้นตอนวิธีที่ใช้วิธีการเลือก ตัวเลือกที่ดีที่สุด เท่าที่เห็น ณ ตอนนั้นโดยไม่คำนึงถึงว่าการเลือกตัวเลือกดังกล่าวจะทำให้คำตอบนั้นดีสุดหรือไม่ โดยปกติจะใช้ Greedy Algorithm ในกรณีที่พิสูจน์ได้ว่า ถึงเลือกตัวเลือกไปแบบไม่คิดอะไรมาก ณ ตอนนั้น ทำเช่นนี้ไปเรื่อย ๆ ย่อมได้คำตอบที่ดีสุดเสมอ

ถ้าไม่นับ Greedy Algorithm อย่าง Dijkstra's Algorithm, Kruskal's Algorithm, Prim's Algorithm แล้ว ปกติ TOI ไม่ค่อยออกโจทย์ปัญหา Greedy Algorithm อื่น ๆ เพราะฉะนั้น ขอข้ามหัวข้อนี้ไป (สำหรับการหา Longest Increasing Subsequence ใน `O(n log n)` จะนำไปรวมในส่วน Dynamic Programming)

## 2.4 Dynamic Programming

_Coming Soon_